#!/usr/bin/perl
use warnings;
use strict;

sub do_menu($$\*;$$);
my %i=(
	grub=>{
		exit=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			return if 'shell'eq$e->{exit};
			return if 'config'eq$e->{exit};

			print {$h} ('	'x$o),q(menuentry '),$e->{title},q(' );
			print {$h} join ' ', map {'--class '.$_} split /,/, $e->{class} if defined $e->{class};
			print {$h} qq( {\n),('	'x$o),qq(	$e->{exit}\n),('	'x$o),qq(}\n);
		},
		kfreebsd=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			print {$h} ('	'x$o),q(menuentry '),$e->{title},q(' );
			print {$h} join ' ', map {'--class '.$_} split /,/, $e->{class} if defined $e->{class};
			print {$h} qq( {\n),('	'x$o),qq(	echo	'Loading kernel ...'\n),('	'x$o);
			print {$h} qq(	$e->{type}	$e->{kernel}\n);
			print {$h} ('	'x$o),qq(	echo	'Loading initial ramdisk ...'\n),('	'x$o),qq(	kfreebsd_module $e->{initrd} type=mfs_root\n) if defined $e->{initrd};
			print {$h} map {('	'x$o),qq(	set $_\n)} split / /, $e->{command} if defined $e->{command};
			print {$h} ('	'x$o),qq(	echo	'Booting ...'\n),('	'x$o),qq(}\n);
		},
		memdisk=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			print {$h} ('	'x$o),q(menuentry '),$e->{title},q(' );
			print {$h} join ' ', map {'--class '.$_} split /,/, $e->{class} if defined $e->{class};
			print {$h} qq( {\n),('	'x$o),qq(	echo	'Loading memdisk ...'\n),('	'x$o);
			print {$h} qq(	linux16	/memdisk);
			print {$h} qq( $e->{command}) if defined $e->{command};
			print {$h} qq(\n),('	'x$o),qq(	echo	'Loading initial ramdisk ...'\n),('	'x$o),qq(	initrd16	$e->{initrd}) if defined $e->{initrd};
			print {$h} qq(\n),('	'x$o),qq(	echo	'Booting ...'\n),('	'x$o),qq(}\n);
		},
		submenu=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			print {$h} ('	'x$o),q(submenu '),$e->{title},q(' );
			print {$h} join ' ', map {'--class '.$_} split /,/, $e->{class} if defined $e->{class};
			print {$h} qq( {\n);
			do_menu(grub=>$e->{tag},*$h,$t,$o+1);
			print {$h} ('	'x$o),qq(}\n);
		}
	},
	pxelinux=>{
		submenu=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			print {$h} ('	'x$o),q(menu begin ),$e->{tag},qq(\n);
			print {$h} ('	'x$o),q(	include debian-installer/boot-screens/stdmenu.cfg),qq(\n);
			unless(defined $e->{hotkey}){
			}elsif($e->{title}=~s/^($e->{hotkey})/^$1/){
			}elsif($e->{title}=~s/ ($e->{hotkey})/ ^$1/){
			}elsif($e->{title}=~s/($e->{hotkey})/^$1/){
			}
			print {$h} ('	'x$o),q(	menu title ),$e->{lable},qq(\n) if defined $e->{lable};;
			print {$h} ('	'x$o),q(	menu label ),$e->{title},qq(\n) if defined $e->{title};;
			print {$h} ('	'x$o),qq(	text help\n),('	'x($o+2)),$e->{help},qq(\n),('	'x$o),qq(\tendtext\n) if defined $e->{help};;
			print {$h} ('	'x$o),q(	label back),$e->{tag},qq(\n);
			print {$h} ('	'x$o),q(		menu label ^Back..),qq(\n);
			print {$h} ('	'x$o),qq(		text help\n),('	'x($o+3)),$e->{backhelp},qq(\n),('	'x$o),qq(\t\tendtext\n) if defined $e->{backhelp};;
			print {$h} ('	'x$o),q(		menu exit),qq(\n);
			do_menu(pxelinux=>$e->{tag},*$h,$t,$o+1);
			print {$h} ('	'x$o),qq(menu end\n);
		},
		subfile=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;
			
			warn unless defined $e->{file};
			print {$h} ('	'x$o),q(default ),$e->{tag},qq(\n) if defined $e->{default} and ! $o;
			print {$h} ('	'x$o),q(label ),$e->{tag},qq(\n);
			print {$h} ('	'x$o),qq(	text help\n),('	'x($o+2)),$e->{help},qq(\n),('	'x$o),qq(\tendtext\n) if defined $e->{help};;
			print {$h} ('	'x$o),q(	menu default),qq(\n) if defined $e->{default};
			unless(defined $e->{hotkey}){
			}elsif($e->{title}=~s/^($e->{hotkey})/^$1/){
			}elsif($e->{title}=~s/ ($e->{hotkey})/ ^$1/){
			}elsif($e->{title}=~s/($e->{hotkey})/^$1/){
			}
			print {$h} ('	'x$o),q(	menu label ),$e->{title},qq(\n) if defined $e->{title};
			print {$h} ('	'x$o),q(	config ),$e->{file},qq(\n);
		}
	},
	ipxe2=>{
		exit=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			print {$h} q(:),$e->{tag},"\n",$e->{exit},qq( || goto debug-$e->{tag}\ngoto $e->{under}\n\n);
			print {$h} q(:debug-),$e->{tag},qq(\nshell\ngoto $e->{under}\n\n);
		},
		memdisk=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			print {$h} q(:),$e->{tag};
			print {$h} qq(\necho	'Loading kernel ...'\n);
			print {$h} qq(kernel	../tftpboot/memdisk);
			print {$h} qq( $e->{command}) if defined $e->{command};
			print {$h} qq( || goto debug-$e->{tag}\necho	'Loading initial ramdisk ...'\ninitrd	$e->{initrd}) if defined $e->{initrd};
			print {$h} qq( || goto debug-$e->{tag}\nimgstat\necho	'Booting ...'\nboot || goto debug-$e->{tag}\nimgfree || goto debug-$e->{tag}\ngoto $e->{under}\n\n);
			print {$h} q(:debug-),$e->{tag},qq(\nshell\ngoto $e->{under}\n\n);
		},
		kfreebsd=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			print {$h} q(:),$e->{tag};
			print {$h} qq(\necho	'Loading kernel ...'\nimgstat\nshell\n);
				warn "unfinished code";
				print {$h} qq(kernel	$e->{kernel});
				print {$h} qq( $e->{command}) if defined $e->{command};
				print {$h} qq( || goto debug-$e->{tag}\necho	'Loading initial ramdisk ...'\ninitrd	$e->{initrd}) if defined $e->{initrd};
				print {$h} map {qq( || goto debug-$e->{tag}\necho	'Loading initial ramdisk ...'\ninitrd	$_)} split /:/, $e->{xinitrd} if defined $e->{xinitrd};
				print {$h} qq( || goto debug-$e->{tag}\nimgstat || goto debug-$e->{tag}\necho	'Booting ...'\nboot || goto debug-$e->{tag}\nimgfree || goto debug-$e->{tag}\ngoto $e->{under}\n\n);
				print {$h} q(:debug-),$e->{tag},qq(\nshell\ngoto $e->{under}\n\n);
		},
		submenu=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			print {$h} q(:),$e->{tag};
			print {$h} qq(\nmenu --name $e->{tag} $e->{title}\n);
			do_menu(ipxe1=>$e->{tag},*$h,$e->{tag},$o+1);
			print {$h} qq(item --menu $e->{tag} $e->{under}	Back to Parrent menu\n);
			print {$h} qq(choose --menu $e->{tag} target || goto $e->{under}\nmenu --name $e->{tag} --delete\ngoto \${target}\n\n);
		},
	},
);
$i{pxelinux}{basic}=sub{
	my $h=shift; #handle
	my $e=shift; #entry
	my $t=shift;
	my $o=shift;

	if('linux16'eq$e->{type}){
	}elsif('linux'eq$e->{type}){
	}elsif('multiboot'eq$e->{type}){
	}elsif('ipxelong'eq$e->{type}){
		return
	}elsif('exit'eq$e->{type}){
		return
	}else{
		warn qq(unknown type $e->{type});
	}

	#todo subfile ###
	warn unless defined $e->{kernel};
	print {$h} ('	'x$o),q(default ),$e->{tag},qq(\n) if defined $e->{default} and ! $o;
	print {$h} ('	'x$o),q(label ),$e->{tag},qq(\n);
	print {$h} ('	'x$o),qq(	text help\n),('	'x($o+2)),$e->{help},qq(\n),('	'x$o),qq(\tendtext\n) if defined $e->{help};;
	print {$h} ('	'x$o),q(	menu default),qq(\n) if defined $e->{default};
	unless(defined $e->{hotkey}){
	}elsif($e->{title}=~s/^($e->{hotkey})/^$1/){
	}elsif($e->{title}=~s/ ($e->{hotkey})/ ^$1/){
	}elsif($e->{title}=~s/($e->{hotkey})/^$1/){
	}
	print {$h} ('	'x$o),q(	menu label ),$e->{title},qq(\n) if defined $e->{title};
	print {$h} ('	'x$o),q(	kernel ),$e->{kernel},qq(\n);
	print {$h} ('	'x$o),q(	initrd ),$e->{initrd},qq(\n) if defined $e->{initrd};
	print {$h} ('	'x$o),q(	append ),$e->{command},qq(\n) if defined $e->{command};
};
$i{grub}{basic}=sub{
	my $h=shift; #handle
	my $e=shift; #entry
	my $t=shift;
	my $o=shift;

	#todo hotkey, default ###
	#todo subfile ###
	my $t2;
	if('linux16'eq$e->{type}){
		$t2='initrd16';
	}elsif('linux'eq$e->{type}){
		$t2='initrd';
	}elsif('multiboot'eq$e->{type}){
		$t2='error';
	}elsif('ipxelong'eq$e->{type}){
		return
	}elsif($i{grub}{$e->{type}}){
		return $i{grub}{$e->{type}}($h,$e,$t,$o)
	}else{
		warn qq(unknown type $e->{type});
	}

	warn unless defined $e->{kernel};
	print {$h} ('	'x$o),q(menuentry '),$e->{title},q(' );
	print {$h} join ' ', map {'--class '.$_} split /,/, $e->{class} if defined $e->{class};
	print {$h} qq( {\n),('	'x$o),qq(	echo	'Loading kernel ...'\n),('	'x$o);
	print {$h} qq(	$e->{type}	$e->{kernel});
	print {$h} qq( $e->{command}) if defined $e->{command};
	print {$h} qq(\n),('	'x$o),qq(	echo	'Loading initial ramdisk ...'\n),('	'x$o),qq(	$t2	$e->{initrd}) if defined $e->{initrd};
	print {$h} qq(\n),('	'x$o),qq(	echo	'Booting ...'\n),('	'x$o),qq(}\n);
};
$i{ipxe1}{basic}=sub{
	my $h=shift; #handle
	my $e=shift; #entry
	my $t=shift;
	my $o=shift;

	if('kfreebsd'eq$e->{type}){
		return;
	}elsif('submenu'eq$e->{type}){
	}elsif('linux16'eq$e->{type}){
	}elsif('linux'eq$e->{type}){
	}elsif('memdisk'eq$e->{type}){
	}elsif('exit'eq$e->{type}){
	}elsif('multiboot'eq$e->{type}){
	}elsif('ipxelong'eq$e->{type}){
	}else{
		warn qq(unknown type $e->{type});
	}

	print {$h} q(item ),($t?"--menu $t ":''),($e->{hotkey}?"--key $e->{hotkey} ":''),($e->{default}?"--default ":''),$e->{tag},qq(	$e->{title}\n);
};
$i{ipxe2}{basic}=sub{
	my $h=shift; #handle
	my $e=shift; #entry
	my $t=shift;
	my $o=shift;

	if('kfreebsd'eq$e->{type}){
		return;
	}elsif('linux16'eq$e->{type}){
	}elsif('linux'eq$e->{type}){
	}elsif('multiboot'eq$e->{type}){
	}elsif('ipxelong'eq$e->{type}){
	}else{
		warn qq(unknown type $e->{type});
	}

	warn unless defined $e->{kernel};
	print {$h} q(:),$e->{tag};
	print {$h} qq(\necho	'Loading kernel ...'\n);
	print {$h} qq(kernel	$e->{kernel});
	print {$h} qq( $e->{command}) if defined $e->{command};
	print {$h} qq( || goto debug-$e->{tag}\necho	'Loading initial ramdisk ...'\ninitrd	$e->{initrd}) if defined $e->{initrd};
	print {$h} map {qq( || goto debug-$e->{tag}\necho	'Loading initial ramdisk ...'\ninitrd	$_)} split /:/, $e->{xinitrd} if defined $e->{xinitrd};
	print {$h} qq( || goto debug-$e->{tag}\nimgstat || goto debug-$e->{tag}\necho	'Booting ...'\nboot || goto debug-$e->{tag}\nimgfree || goto debug-$e->{tag}\ngoto $e->{under}\n\n);
	print {$h} q(:debug-),$e->{tag},qq(\nshell\ngoto $e->{under}\n\n);
};
sub entry($\*$;$$){
	my $t=shift; #target
	my ($h,$e)=@_;

	if($i{$t}{$e->{type}}){
		return $i{$t}{$e->{type}}(@_)
	}elsif($i{$t}{basic}){
		return $i{$t}{basic}(@_);
	}else{
		die "unknown type $t";
	}
}
sub out($\*){
	my $t=shift; #target
	my $h=shift; #handle

	print {$h} qq(#!$t\n#\n# DO NOT EDIT THIS FILE\n#\n# It is automatically generated by netmenubuilder.\n#\n\n### BEGIN $0: $ARGV ###\n);
	open my $lib, '<', $t.'.lib' or die;
	print {$h} $_ while(<$lib>);
	close $lib;
	$i{$t}{out}($h);
	print {$h} qq(### END $0: $ARGV ###\n);
}
my @order;
my $count;
$i{pxelinux}{out}=sub (\*){
	my $h=shift;

	do_menu(pxelinux=>menu=>*$h,menu=>0);
};
$i{grub}{out}=sub (\*){
	my $h=shift;

	do_menu(grub=>menu=>*$h,menu=>0);
	foreach my $e (@order){
		next unless defined $e;
	}
};
sub do_menu($$\*;$$){
	my $g=shift;
	my $m=shift;
	my $h=shift;
	my $t=shift;
	my $o=shift;

	$o=0 unless defined $o;
	foreach my $e (@order){
		next unless defined $e;
		unless(defined $e->{type}){
			warn 'undefined type for entry';
			$e=undef;
			next;
		}
		next unless $e->{under}eq$m;
		next if(defined $e->{only}); # meaning inverted by parser
		entry($g,*$h,$e,$t,$o);
	}
}
$i{ipxe}{out}=sub (\*){
	my $h=shift;

	print {$h} qq(:menu\nmenu --name menu\n);
	do_menu(ipxe1=>menu=>*$h,menu=>0);
	print {$h} qq(choose --menu menu target || exit\nmenu --name menu --delete\ngoto \${target}\n\n);
	foreach my $e (@order){
		next unless defined $e;
		unless(defined $e->{type}){
			warn 'undefined type for entry';
			next;
		}
		next if(defined $e->{only}); # meaning inverted by parser
		entry('ipxe2',*$h,$e,menu=>0);
	}
};
my $mode=shift;
while (<>){
	next if /^[ 	]*[#;]/;
	next if m!^[ 	]*//!;
	next if m!^[ 	]*$!;
	if(/^\[([0-9a-zA-Z-]+)\]/){
		$count++;
		$order[$count]{tag}=$1;
	}elsif($count){
		s!^[ 	]*!!;
		s![ 	]*$!!;
		if(/^(only)[ 	]*=[ 	]*(.*)$/i){
			my @a = grep {$_ eq$mode} split /,/, $2;
			next if scalar @a;
			$order[$count]{lc($1)}++;
		}elsif(/^([0-9a-zA-Z]+)[ 	]*=[ 	]*(.*)$/){
			$order[$count]{lc($1)}=$2;
		}else{
			warn $_;
			die die die 'bad format';
		}
	}else{
		warn $_;
		die die die 'bad format';
	}
}
foreach my $e (@order){
	next unless defined $e;
	$e->{under}='menu' unless(defined $e->{under});
}
out($mode=>*STDOUT);
