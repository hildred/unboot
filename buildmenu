#!/usr/bin/perl
use warnings;
use strict;

my @order=({(type=>'config')});

sub do_menu($$\*;$$);
my %i=(
	grub=>{
		config=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			print {$h} ('	'x$o), 'set default="'.$e->{default}."\"\n\n" if defined $e->{default};
			print {$h} ('	'x$o), 'set timeout='.$e->{timeout}."\n\n" if defined $e->{timeout};
			print {$h} ('	'x$o), 'load_video'."\n";
			print {$h} ('	'x$o), 'start_ser'."\n\n";
		},
		gap=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			print {$h} ('	'x$o),q(menuenty '),$e->{title},q(');
			print {$h} ' ',join ' ', map {'--class '.$_} split /,/, $e->{class} if defined $e->{class};
			print {$h} qq( {}\n);
		},
		gapvar=>sub{warn "unfinished code";},
		'read-var'=>sub{warn "unfinished code";},
		'submenu-var'=>sub{warn "unfinished code";},
		'submenu-edit'=>sub{warn "unfinished code";},
		exit=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			print {$h} ('	'x$o),q(menuentry '),$e->{title},q(');
			print {$h} ' --users ',"'", $e->{users},"'" if defined $e->{users};
			print {$h} ' ',join ' ', map {'--class '.$_} split /,/, $e->{class} if defined $e->{class};
			print {$h} qq( {\n),('	'x$o),qq(	$e->{exit}\n),('	'x$o),qq(}\n);
		},
		kfreebsd=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			print {$h} ('	'x$o),q(menuentry '),$e->{title},q(');
			print {$h} ' --users ',"'", $e->{users},"'" if defined $e->{users};
			print {$h} ' ',join ' ', map {'--class '.$_} split /,/, $e->{class} if defined $e->{class};
			print {$h} qq( {\n),('	'x$o),qq(	echo	'Loading kernel ...'\n),('	'x$o);
			print {$h} qq(	$e->{type}	$e->{kernel}\n);
			print {$h} ('	'x$o),qq(	echo	'Loading initial ramdisk ...'\n),('	'x$o),qq(	kfreebsd_module $e->{initrd} type=mfs_root\n) if defined $e->{initrd};
			print {$h} map {('	'x$o),qq(	set $_\n)} split / /, $e->{command} if defined $e->{command};
			print {$h} ('	'x$o),qq(	echo	'Booting ...'\n),('	'x$o),qq(}\n);
		},
		memdisk=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			print {$h} ('	'x$o),q(menuentry '),$e->{title},q(');
			print {$h} ' --users ',"'", $e->{users},"'" if defined $e->{users};
			print {$h} ' ',join ' ', map {'--class '.$_} split /,/, $e->{class} if defined $e->{class};
			print {$h} qq( {\n),('	'x$o),qq(	echo	'Loading memdisk ...'\n),('	'x$o);
			print {$h} qq(	linux16	/memdisk);
			print {$h} qq( $e->{command}) if defined $e->{command};
			print {$h} qq(\n),('	'x$o),qq(	echo	'Loading initial ramdisk ...'\n),('	'x$o),qq(	initrd16	$e->{initrd}) if defined $e->{initrd};
			print {$h} qq(\n),('	'x$o),qq(	echo	'Booting ...'\n),('	'x$o),qq(}\n);
		},
		submenu=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			print {$h} ('	'x$o),q(submenu '),$e->{title},q(');
			print {$h} ' --users ',"'", $e->{users},"'" if defined $e->{users};
			print {$h} ' ',join ' ', map {'--class '.$_} split /,/, $e->{class} if defined $e->{class};
			print {$h} qq( {\n);
			do_menu(grub=>$e->{tag},*$h,$t,$o+1);
			print {$h} ('	'x$o),qq(}\n);
		}
	},
	pxelinux=>{
		config=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			warn "unimplemented" if defined $e->{class};
			warn "unimplemented" if defined $e->{users};
			warn print {$h} ('	'x$o), 'set default="'.$e->{default}."\"\n\n" if defined $e->{default};
			warn print {$h} ('	'x$o), 'set timeout='.$e->{timeout}."\n\n" if defined $e->{timeout};
		},
		gap=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			warn "unimplemented" if defined $e->{class};
			warn "unimplemented" if defined $e->{users};
			print {$h} ('	'x$o),q(menu seperator),qq(\n);
			warn "unfinished code";
		},
		gapvar=>sub{warn "unfinished code";},
		'submenu-var'=>sub{warn "unfinished code";},
		'submenu-edit'=>sub{warn "unfinished code";},
		'read-var'=>sub{warn "unfinished code";},
		kfreebsd=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			warn "unimplemented" if defined $e->{class};
			warn "unimplemented" if defined $e->{users};
			warn unless defined $e->{kernel};
			print {$h} ('	'x$o),q(default ),$e->{tag},qq(\n) if defined $e->{default} and ! $o;
			print {$h} ('	'x$o),q(label ),$e->{tag},qq(\n);
			print {$h} ('	'x$o),qq(	text help\n),('	'x($o+2)),$e->{help},qq(\n),('	'x$o),qq(\tendtext\n) if defined $e->{help};;
			print {$h} ('	'x$o),q(	menu default),qq(\n) if defined $e->{default};
			unless(defined $e->{hotkey}){
			}elsif($e->{title}=~s/^($e->{hotkey})/^$1/i){
			}elsif($e->{title}=~s/ ($e->{hotkey})/ ^$1/i){
			}elsif($e->{title}=~s/($e->{hotkey})/^$1/i){
			}else{
				warn "unmarked hotkey on $e->{tag}: $e->{title}";
			}
			print {$h} ('	'x$o),q(	menu label ),$e->{title},qq(\n) if defined $e->{title};
			print {$h} ('	'x$o),q(	kernel /mboot.c32),qq(\n);
			print {$h} ('	'x$o),q(	append ),$e->{kernel};
			print {$h} q( ),$e->{command} if defined $e->{command};
			print {$h} ' -- ',$e->{initrd} if defined $e->{initrd};
			print {$h} qq(\n)
		},
		memdisk=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			warn "unimplemented" if defined $e->{class};
			warn "unimplemented" if defined $e->{users};
			warn unless defined $e->{initrd};
			print {$h} ('	'x$o),q(default ),$e->{tag},qq(\n) if defined $e->{default} and ! $o;
			print {$h} ('	'x$o),q(label ),$e->{tag},qq(\n);
			print {$h} ('	'x$o),qq(	text help\n),('	'x($o+2)),$e->{help},qq(\n),('	'x$o),qq(\tendtext\n) if defined $e->{help};;
			print {$h} ('	'x$o),q(	menu default),qq(\n) if defined $e->{default};
			unless(defined $e->{hotkey}){
			}elsif($e->{title}=~s/^($e->{hotkey})/^$1/i){
			}elsif($e->{title}=~s/ ($e->{hotkey})/ ^$1/i){
			}elsif($e->{title}=~s/($e->{hotkey})/^$1/i){
			}else{
				warn "unmarked hotkey on $e->{tag}: $e->{title}";
			}
			print {$h} ('	'x$o),q(	menu label ),$e->{title},qq(\n) if defined $e->{title};
			print {$h} ('	'x$o),q(	kernel /memdisk),qq(\n);
			print {$h} ('	'x$o),q(	initrd ),$e->{initrd},qq(\n) if defined $e->{initrd};
			print {$h} ('	'x$o),q(	append ),$e->{command},qq(\n) if defined $e->{command};
		},
		submenu=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			warn "unimplemented" if defined $e->{class};
			warn "unimplemented" if defined $e->{users};
			print {$h} ('	'x$o),q(menu begin ),$e->{tag},qq(\n);
			print {$h} ('	'x$o),q(	include debian-installer/boot-screens/stdmenu.cfg),qq(\n);
			unless(defined $e->{hotkey}){
			}elsif($e->{title}=~s/^($e->{hotkey})/^$1/i){
			}elsif($e->{title}=~s/ ($e->{hotkey})/ ^$1/i){
			}elsif($e->{title}=~s/($e->{hotkey})/^$1/i){
			}else{
				warn "unmarked hotkey on $e->{tag}: $e->{title}";
			}
			print {$h} ('	'x$o),q(	menu title ),$e->{lable},qq(\n) if defined $e->{lable};;
			print {$h} ('	'x$o),q(	menu label ),$e->{title},qq(\n) if defined $e->{title};;
			print {$h} ('	'x$o),qq(	text help\n),('	'x($o+2)),$e->{help},qq(\n),('	'x$o),qq(\tendtext\n) if defined $e->{help};;
			print {$h} ('	'x$o),q(	label back),$e->{tag},qq(\n);
			print {$h} ('	'x$o),q(		menu label ^Back..),qq(\n);
			print {$h} ('	'x$o),qq(		text help\n),('	'x($o+3)),$e->{backhelp},qq(\n),('	'x$o),qq(\t\tendtext\n) if defined $e->{backhelp};;
			print {$h} ('	'x$o),q(		menu exit),qq(\n);
			do_menu(pxelinux=>$e->{tag},*$h,$t,$o+1);
			print {$h} ('	'x$o),qq(menu end\n);
		},
		subfile=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;
			
			warn "unimplemented" if defined $e->{class};
			warn "unimplemented" if defined $e->{users};
			warn unless defined $e->{file};
			print {$h} ('	'x$o),q(default ),$e->{tag},qq(\n) if defined $e->{default} and ! $o;
			print {$h} ('	'x$o),q(label ),$e->{tag},qq(\n);
			print {$h} ('	'x$o),qq(	text help\n),('	'x($o+2)),$e->{help},qq(\n),('	'x$o),qq(\tendtext\n) if defined $e->{help};;
			print {$h} ('	'x$o),q(	menu default),qq(\n) if defined $e->{default};
			unless(defined $e->{hotkey}){
			}elsif($e->{title}=~s/^($e->{hotkey})/^$1/i){
			}elsif($e->{title}=~s/ ($e->{hotkey})/ ^$1/i){
			}elsif($e->{title}=~s/($e->{hotkey})/^$1/i){
			}else{
				warn "unmarked hotkey on $e->{tag}: $e->{title}";
			}
			print {$h} ('	'x$o),q(	menu label ),$e->{title},qq(\n) if defined $e->{title};
			print {$h} ('	'x$o),q(	config ),$e->{file},qq(\n);
		}
	},
	ipxe1=>{
		config=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			warn "unimplemented" if defined $e->{class};
			warn "unimplemented" if defined $e->{users};
			print {$h} ('	'x$o), 'set default="'.$e->{default}."\"\n\n" if defined $e->{default};
			print {$h} ('	'x$o), 'set timeout='.$e->{timeout}."\n\n" if defined $e->{timeout};
		},
		gap=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			warn "unimplemented" if defined $e->{class};
			warn "unimplemented" if defined $e->{users};
			print {$h} q(item ),($t?"--menu $t ":''),"--gap",($e->{title}?" $e->{title}":''),qq(\n);
		},
		gapvar=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			warn "unimplemented" if defined $e->{class};
			warn "unimplemented" if defined $e->{users};
			print {$h} qq(isset \${$e->{var}} && );
			print {$h} q(item ),($t?"--menu $t ":''),"--gap ",qq($e->{titlet} || );
			print {$h} q(item ),($t?"--menu $t ":''),"--gap ",qq($e->{titlef}\n);
		},
		value=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			warn "unimplemented" if defined $e->{class};
			warn "unimplemented" if defined $e->{users};
			$e->{tag}=$e->{value} if defined $e->{value};
			unless(defined $e->{hotkey}){
			}elsif($e->{title}=~s/^($e->{hotkey})/($1)/i){
			}elsif($e->{title}=~s/ ($e->{hotkey})/ ($1)/i){
			}elsif($e->{title}=~s/($e->{hotkey})/($1)/i){
			}else{
				warn "unmarked hotkey on $e->{tag}: $e->{title}";
			}
			print {$h} q(item ),($t?"--menu $t ":''),($e->{hotkey}?"--key $e->{hotkey} ":''),($e->{default}?"--default ":''),$e->{tag},qq(	$e->{title}\n);
		},
	},
	ipxe2=>{
		config=>sub{},
		gap=>sub{},
		gapvar=>sub{},
		value=>sub{},
		sanboot=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			print {$h} q(:),$e->{tag},"",qq(\nisset \${sanid} && inc sanid || set sanid:int8 0x80 \nsanboot --drive \${sanid:int8} $e->{path} || goto debug-$e->{tag}\ngoto $e->{under}\n\n);
			print {$h} q(:debug-),$e->{tag},qq(\nshell\ngoto $e->{under}\n\n);
		},
		sanhook=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			print {$h} q(:),$e->{tag},"",qq(\nisset \${sanid} && inc sanid || set sanid:int8 0x80 \nsanhook --drive \${sanid:int8} $e->{path} || goto debug-$e->{tag}\ngoto $e->{under}\n\n);
			print {$h} q(:debug-),$e->{tag},qq(\nshell\ngoto $e->{under}\n\n);
		},
		exit=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			print {$h} q(:),$e->{tag},"\n",$e->{exit},qq( || goto debug-$e->{tag}\ngoto $e->{under}\n\n);
			print {$h} q(:debug-),$e->{tag},qq(\nshell\ngoto $e->{under}\n\n);
		},
		memdisk=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			print {$h} q(:),$e->{tag};
			print {$h} qq(\necho	Loading kernel ...\n);
			print {$h} qq(kernel	../tftpboot/memdisk);
			print {$h} qq( $e->{command}) if defined $e->{command};
			print {$h} qq( || goto debug-$e->{tag}\necho	Loading initial ramdisk ...\ninitrd	$e->{initrd}) if defined $e->{initrd};
			print {$h} qq( || goto debug-$e->{tag}\nimgstat\necho	Booting ...\nboot || goto debug-$e->{tag}\nimgfree || goto debug-$e->{tag}\ngoto $e->{under}\n\n);
			print {$h} q(:debug-),$e->{tag},qq(\nshell\ngoto $e->{under}\n\n);
		},
		kfreebsd=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			print {$h} q(:),$e->{tag};
			print {$h} qq(\necho	Loading kernel ...\nimgstat\nshell\n);
			warn "unfinished code";
				print {$h} qq(kernel	$e->{kernel});
				print {$h} qq( $e->{command}) if defined $e->{command};
				print {$h} qq( || goto debug-$e->{tag}\necho	Loading initial ramdisk ...\ninitrd	$e->{initrd}) if defined $e->{initrd};
				print {$h} map {qq( || goto debug-$e->{tag}\necho	Loading initial ramdisk ...\ninitrd	$_)} split /:/, $e->{xinitrd} if defined $e->{xinitrd};
				print {$h} qq( || goto debug-$e->{tag}\nimgstat || goto debug-$e->{tag}\necho	Booting ...\nboot || goto debug-$e->{tag}\nimgfree || goto debug-$e->{tag}\ngoto $e->{under}\n\n);
				print {$h} q(:debug-),$e->{tag},qq(\nshell\ngoto $e->{under}\n\n);
		},
		submenu=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			$e->{label}=$e->{title} unless defined $e->{label};
			print {$h} q(:),$e->{tag};
			print {$h} qq(\nmenu --name $e->{tag} $e->{label}\n);
			do_menu(ipxe1=>$e->{tag},*$h,$e->{tag},$o+1);
			print {$h} qq(item --menu $e->{tag} --gap\n);
			print {$h} qq(item --menu $e->{tag} $e->{under}	Back to Parrent menu\n);
			print {$h} qq(choose --menu $e->{tag} target || goto $e->{under}\nmenu --name $e->{tag} --delete\n);
			print {$h} join "\n", split(';', $e->{extended}), '' if defined $e->{extended};
			print {$h} qq(goto \${target}\n\n);
		},
		'read-var'=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			print {$h} q(:),$e->{tag}, qq(\nread $e->{var} || clear $e->{var} \n);
			print {$h} join "\n", split(';', $e->{extended}), '' if defined $e->{extended};
			print {$h} qq(goto $e->{under}\n\n);
		},
		'submenu-var'=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			$e->{label}=$e->{title} unless defined $e->{label};
			print {$h} q(:),$e->{tag};
			print {$h} qq(\nmenu --name $e->{tag} $e->{label}\n);
			do_menu(ipxe1=>$e->{tag},*$h,$e->{tag},$o+1);
			print {$h} qq(choose --menu $e->{tag} $e->{var} || $e->{cancel}\n);
			print {$h} join "\n", split(';', $e->{extended}), '' if defined $e->{extended};
			print {$h} qq(goto $e->{under}\n\n);
		},
		'submenu-edit'=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			if('linux16'eq$e->{subtype}){
			}elsif('linux'eq$e->{subtype}){
			}elsif('multiboot'eq$e->{subtype}){
			#}elsif('ipxelong'eq$e->{subtype}){
			}else{
				warn qq(unknown subtype $e->{subtype});
			}

			warn unless defined $e->{kernel};
			$e->{label}=$e->{title} unless defined $e->{label};
			print {$h} q(:),$e->{tag};
			print {$h} qq(\nset kernel $e->{kernel}\n);
			print {$h} qq(set command $e->{command}\n) if defined $e->{command};
			print {$h} qq(set initrd $e->{initrd}\n) if defined $e->{initrd};
			print {$h} q(:),$e->{tag};
			print {$h} qq(-cont\nmenu --name $e->{tag} $e->{label}\n);
			print {$h} qq(item --menu $e->{tag} --gap \${space:string}Kernel: \${kernel}\n);
			print {$h} qq(item --menu $e->{tag} --gap \${space:string}Initrd: \${initrd}\n);
			print {$h} qq(item --menu $e->{tag} --gap Command: \${command}\n);
			print {$h} qq(item --menu $e->{tag} --gap\n);
			print {$h} qq(item --menu $e->{tag} --key K	chkr-$e->{tag}	Edit (K)ernel\n);
			print {$h} qq(item --menu $e->{tag} --key I	chin-$e->{tag}	Edit (I)nitrd\n);
			print {$h} qq(item --menu $e->{tag} --key C	chco-$e->{tag}	Edit (C)command\n);
			print {$h} qq(item --menu $e->{tag} --gap\n);
			print {$h} qq(item --menu $e->{tag} --default $e->{tag}-boot	Boot\n);
			print {$h} qq(item --menu $e->{tag} --gap\n);
			print {$h} qq(item --menu $e->{tag} $e->{under}	Back to Parrent menu\n);
			print {$h} qq(choose --menu $e->{tag} target || goto $e->{under}\nmenu --name $e->{tag} --delete\ngoto \${target}\n);

			print {$h} q(:chkr-),$e->{tag}, qq(\nread kernel || clear kernel \ngoto $e->{tag}-cont\n);
			print {$h} q(:chin-),$e->{tag}, qq(\nread initrd || clear initrd \ngoto $e->{tag}-cont\n);
			print {$h} q(:chco-),$e->{tag}, qq(\nread command || clear command \ngoto $e->{tag}-cont\n);
			print {$h} q(:),$e->{tag}, qq(-boot\necho	Loading kernel ...\n);
			print {$h} q(kernel	${kernel} ${command} || goto debug-),$e->{tag};
			print {$h} qq(\necho	Loading initial ramdisk ...\ninitrd	\${initrd});
			#print {$h} map {qq( || goto debug-$e->{tag}\necho	Loading initial ramdisk ...\ninitrd	$_)} split /:/, $e->{xinitrd} if defined $e->{xinitrd};
			print {$h} qq( || goto debug-$e->{tag}\nimgstat || goto debug-$e->{tag}\necho	Booting ...\nboot || goto debug-$e->{tag}\nimgfree || goto debug-$e->{tag}\ngoto $e->{under}\n\n);
			print {$h} q(:debug-),$e->{tag},qq(\nshell\ngoto $e->{tag}\n\n);
		},
	},
);
$i{pxelinux}{basic}=sub{
	my $h=shift; #handle
	my $e=shift; #entry
	my $t=shift;
	my $o=shift;

	warn "unimplemented" if defined $e->{class};
	warn "unimplemented" if defined $e->{users};
	if('linux16'eq$e->{type}){
	}elsif('linux'eq$e->{type}){
	}elsif('multiboot'eq$e->{type}){
	}else{
		warn qq(unknown type $e->{type});
	}

	#todo subfile ###
	warn unless defined $e->{kernel};
	print {$h} ('	'x$o),q(default ),$e->{tag},qq(\n) if defined $e->{default} and ! $o;
	print {$h} ('	'x$o),q(label ),$e->{tag},qq(\n);
	print {$h} ('	'x$o),qq(	text help\n),('	'x($o+2)),$e->{help},qq(\n),('	'x$o),qq(\tendtext\n) if defined $e->{help};;
	print {$h} ('	'x$o),q(	menu default),qq(\n) if defined $e->{default};
	unless(defined $e->{hotkey}){
	}elsif($e->{title}=~s/^($e->{hotkey})/^$1/i){
	}elsif($e->{title}=~s/ ($e->{hotkey})/ ^$1/i){
	}elsif($e->{title}=~s/($e->{hotkey})/^$1/i){
	}else{
		warn "unmarked hotkey on $e->{tag}: $e->{title}";
	}
	print {$h} ('	'x$o),q(	menu label ),$e->{title},qq(\n) if defined $e->{title};
	print {$h} ('	'x$o),q(	kernel ),$e->{kernel},qq(\n);
	print {$h} ('	'x$o),q(	initrd ),$e->{initrd},qq(\n) if defined $e->{initrd};
	print {$h} ('	'x$o),q(	append ),$e->{command},qq(\n) if defined $e->{command};
};
$i{grub}{basic}=sub{
	my $h=shift; #handle
	my $e=shift; #entry
	my $t=shift;
	my $o=shift;

	#todo hotkey, default ###
	#todo subfile ###
	my $t2;
	if('linux16'eq$e->{type}){
		$t2='initrd16';
	}elsif('linux'eq$e->{type}){
		$t2='initrd';
	}elsif('multiboot'eq$e->{type}){
		$t2='error';
	}else{
		warn qq(unknown type $e->{type});
	}

	warn unless defined $e->{kernel};
	print {$h} ('	'x$o),q(menuentry '),$e->{title},q(');
	print {$h} ' --users ',"'", $e->{users},"'" if defined $e->{users};
	print {$h} ' ',join ' ', map {'--class '.$_} split /,/, $e->{class} if defined $e->{class};
	print {$h} qq( {\n),('	'x$o),qq(	echo	'Loading kernel ...'\n),('	'x$o);
	print {$h} qq(	$e->{type}	$e->{kernel});
	print {$h} qq( $e->{command}) if defined $e->{command};
	print {$h} qq(\n),('	'x$o),qq(	echo	'Loading initial ramdisk ...'\n),('	'x$o),qq(	$t2	$e->{initrd}) if defined $e->{initrd};
	print {$h} qq(\n),('	'x$o),qq(	echo	'Booting ...'\n),('	'x$o),qq(}\n);
};
$i{ipxe1}{basic}=sub{
	my $h=shift; #handle
	my $e=shift; #entry
	my $t=shift;
	my $o=shift;

	warn "unimplemented" if defined $e->{class};
	warn "unimplemented" if defined $e->{users};
	#todo kfreebsd
	if('kfreebsd'eq$e->{type}){
		return;
	}elsif('submenu'eq$e->{type}){
	}elsif('linux16'eq$e->{type}){
	}elsif('linux'eq$e->{type}){
	}elsif('memdisk'eq$e->{type}){
	}elsif('exit'eq$e->{type}){
	}elsif('multiboot'eq$e->{type}){
	}elsif('ipxelong'eq$e->{type}){
	}elsif('read-var'eq$e->{type}){
	}elsif('submenu-var'eq$e->{type}){
	}elsif('submenu-edit'eq$e->{type}){
	}elsif('sanboot'eq$e->{type}){
	}elsif('sanhook'eq$e->{type}){
	}else{
		warn qq(unknown type $e->{type});
	}

	$e->{label}=$e->{title} unless defined $e->{label};
	unless(defined $e->{hotkey}){
	}elsif($e->{title}=~s/^($e->{hotkey})/($1)/i){
	}elsif($e->{title}=~s/ ($e->{hotkey})/ ($1)/i){
	}elsif($e->{title}=~s/($e->{hotkey})/($1)/i){
	}else{
		warn "unmarked hotkey on $e->{tag}: $e->{title}";
	}
	print {$h} q(item ),($t?"--menu $t ":''),($e->{hotkey}?"--key $e->{hotkey} ":''),($e->{default}?"--default ":''),$e->{tag},qq(	$e->{title}\n);
};
$i{ipxe2}{basic}=sub{
	my $h=shift; #handle
	my $e=shift; #entry
	my $t=shift;
	my $o=shift;

	if('kfreebsd'eq$e->{type}){
		return;
	}elsif('linux16'eq$e->{type}){
	}elsif('linux'eq$e->{type}){
	}elsif('multiboot'eq$e->{type}){
	}elsif('ipxelong'eq$e->{type}){
	}else{
		warn qq(unknown type $e->{type});
	}

	warn unless defined $e->{kernel};
	print {$h} q(:),$e->{tag};
	print {$h} qq(\necho	Loading kernel ...\n);
	print {$h} qq(kernel	$e->{kernel});
	print {$h} qq( $e->{command}) if defined $e->{command};
	print {$h} qq( || goto debug-$e->{tag}\necho	Loading initial ramdisk ...\ninitrd	$e->{initrd}) if defined $e->{initrd};
	print {$h} map {qq( || goto debug-$e->{tag}\necho	Loading initial ramdisk ...\ninitrd	$_)} split /:/, $e->{xinitrd} if defined $e->{xinitrd};
	print {$h} qq( || goto debug-$e->{tag}\nimgstat || goto debug-$e->{tag}\necho	Booting ...\nboot || goto debug-$e->{tag}\nimgfree || goto debug-$e->{tag}\ngoto $e->{under}\n\n);
	print {$h} q(:debug-),$e->{tag},qq(\nshell\ngoto $e->{under}\n\n);
};
sub entry($\*$;$$){
	my $t=shift; #target
	my ($h,$e)=@_;

	if($i{$t}{$e->{type}}){
		return $i{$t}{$e->{type}}(@_)
	}elsif($i{$t}{basic}){
		return $i{$t}{basic}(@_);
	}else{
		die "unknown type $t";
	}
}
sub out($\*){
	my $t=shift; #target
	my $h=shift; #handle

	print {$h} qq(#!$t\n#\n# DO NOT EDIT THIS FILE\n#\n# It is automatically generated by netmenubuilder.\n#\n\n### BEGIN $0: $ARGV ###\n);
	open my $lib, '<', $t.'.lib' or die;
	print {$h} $_ while(<$lib>);
	close $lib;
	$i{$t}{out}($h);
	print {$h} qq(### END $0: $ARGV ###\n);
}
$i{pxelinux}{out}=sub (\*){
	my $h=shift;

	do_menu(pxelinux=>menu=>*$h,menu=>0);
};
$i{grub}{out}=sub (\*){
	my $h=shift;

	do_menu(grub=>menu=>*$h,menu=>0);
	foreach my $e (@order){
		next unless defined $e;
	}
};
sub do_menu($$\*;$$){
	my $g=shift;
	my $m=shift;
	my $h=shift;
	my $t=shift;
	my $o=shift;

	$o=0 unless defined $o;
	foreach my $e (@order){
		next unless defined $e;
		unless(defined $e->{type}){
			warn 'undefined type for entry';
			$e=undef;
			next;
		}
		next unless $e->{under}eq$m;
		next if(defined $e->{only}); # meaning inverted by parser
		entry($g,*$h,$e,$t,$o);
	}
}
$i{ipxe}{out}=sub (\*){
	my $h=shift;

	print {$h} qq(:menu\nmenu --name menu\n);
	do_menu(ipxe1=>menu=>*$h,menu=>0);
	print {$h} qq(choose --menu menu target || exit\nmenu --name menu --delete\ngoto \${target}\n\n);
	foreach my $e (@order){
		next unless defined $e;
		unless(defined $e->{type}){
			warn 'undefined type for entry';
			next;
		}
		next if(defined $e->{only}); # meaning inverted by parser
		entry('ipxe2',*$h,$e,menu=>0);
	}
};

my $mode=shift;
my $count=0;

while (<>){
	next if /^[ 	]*[#;]/;
	next if m!^[ 	]*//!;
	next if m!^[ 	]*$!;
	if(/^\[([0-9a-zA-Z-]+)\]/){
		$count++;
		$order[$count]{tag}=$1;
	}else{
		s!^[ 	]*!!;
		s![ 	]*$!!;
		if(/^(only)[ 	]*=[ 	]*(.*)$/i){
			my @a = grep {$_ eq$mode} split /,/, $2;
			next if scalar @a;
			$order[$count]{lc($1)}++;
		}elsif(/^([0-9a-zA-Z]+)[ 	]*=[ 	]*(.*)$/){
			$order[$count]{lc($1)}=$2;
		}else{
			warn $_;
			die die die 'bad format';
		}
	}
}
foreach my $e (@order){
	next unless defined $e;
	$e->{under}='menu' unless(defined $e->{under});
}
out($mode=>*STDOUT);
