#!/usr/bin/perl
use warnings;
use strict;
use v5.8;
use Locale::Messages qw(dgettext dpgettext);
use Locale::TextDomain 'unboot';

my @order=({(type=>'config')});
my %lines=();
my %menudomain=();
my %go=(target=>'net');

sub do_menu($$\*;$$);
sub entry($\*$;$$);
sub out($\*);

sub _f($@){
	my $string=shift;
	return '' unless grep {$_}@_;
	return sprintf $string, @_;
}
sub ___($$){
	my $e=shift; #entry
	return Locale::Messages::dgettext($menudomain{$e->{file}},$_);
}
sub ___o($$){
	my $e=shift; #entry
	return Locale::Messages::dgettext($menudomain{$e->{file}},@{$e}{@_});
}
sub ___t($){
	my $e=shift; #entry
	return Locale::Messages::dgettext($menudomain{$e->{file}},$e->{title});
}
sub ___h($){
	my $e=shift; #entry
	return Locale::Messages::dpgettext($menudomain{$e->{file}},$e->{title},$e->{hotkey});
}
sub ___p($$$){
	my $e=shift; #entry
	my $ctxt=shift;
	return Locale::Messages::dpgettext($menudomain{$e->{file}},$ctxt,@_);
}
sub xwarn($@){
	my $e=shift; #entry
	my @c=(caller,@{$e}{qw(file line)});
	my $p=shift @c;
	warn sprintf __("%s at %s line %d, %s line %d\n"), join(' ',@_), @c;
}
sub sudochk{
	open my $fh, '-|', qw(sudo -l), @_ or return 0;
	my $list=join '', <$fh>;
	return $_[0]eq$list;
}

sub super{
	if($>>0){
		my $cmd=my $base=shift;
		$base=~s!^.*/([^/]*$)!$1!;
		unless(system qw(super -t -r), $cmd, $base, @_){return system qw(super -r), $cmd, $base, @_}
		if(sudochk $cmd){return system qw(sudo), $cmd, @_}
		warn sprintf __('Not able to gain root permision to run "%s", trying anyway . . .'), $cmd;
		return system @_;
	}else{
		return system @_;
	}
}

sub superopen(*$@){
	use Symbol 'qualify_to_ref';
	my $fh=qualify_to_ref(shift,caller);
	my $mode=shift;
	die unless $mode=~/^[-|]{2}$/;
	if($>>0){
		my $cmd=my $base=shift;
		$base=~s!^.*/([^/]*$)!$1!;
		warn join ', ', @_ if grep {!defined($_)} @_;
		unless(system qw(super -t -r), $cmd, $base, @_){return open $fh, $mode, qw(super -r), $cmd, $base, @_;}
		if(sudochk $cmd){return open $fh, $mode, qw(sudo), $cmd, @_;}
		warn sprintf __('Not able to gain root permision to run "%s", trying anyway . . .'), $cmd;
		return open $fh, $mode, $cmd, @_;
	}else{
		return open $fh, $mode, @_;
	}
}

sub grub_mkrelpath($){
	my $path=shift;
	local $_;
	local $/="\n";
	open(my $fh, '-|', qw(/usr/bin/grub-mkrelpath), $path);
	my @a=<$fh>;
	map {chomp} @a;
	#warn join ', ', map {"'$_'"} @a;
	return 1,@a if close $fh;
	die if $!;
	return $?,@a;
}

sub grub_probe($$){
	my $test=shift;# which test are we doing
	my $obj=shift;# and what are we doing it to
	die sprintf __("nosuch file '%s'"), $obj unless -e $obj;
	local *FH;
	local $_;
	local $/="\n";
	superopen(FH, '-|', qw(/usr/sbin/grub-probe -t), $test, $obj);
	my @a=<FH>;
	map {chomp} @a;
	#warn join ', ', map {"'$_'"} @a;
	return 1,@a if close FH;
	die if $!;
	return $?,@a;
}

sub grub_probe_d($$){
	my $test=shift;# which test are we doing
	my $obj=shift;# and what are we doing it to
	die unless $test and $obj;
	local *FH;
	local $_;
	local $/="\n";
	#warn "'$obj'";
	superopen(FH, '-|', qw(/usr/sbin/grub-probe -dt), $test, $obj);
	my @a=<FH>;
	map {chomp} @a;
	#warn join ', ', map {"'$_'"} @a;
	return 1,@a if close FH;
	die if $!;
	return $?,@a;
}

sub is_path_readable_by_grub($){
	my$path=shift;

	# abort if path doesn't exist
	return 0 unless defined $path;
	return 0 unless -e $path;

	# abort if file is in a filesystem we can't read
	my @a=grub_probe fs=>$path;
	#warn join ', ', @a;
	return 0 unless $a[0];

	# ... or if we can't figure out the abstraction module, for example if
	# memberlist fails on an LVM volume group.
	my @abstraction=grub_probe abstraction=>$path;
	#warn join ', ', @abstraction;
	return 0 unless shift @abstraction;

	### TODO
	#if [ x$GRUB_ENABLE_CRYPTODISK = xy ]; then
	#	return 0
	#fi

	#for abstraction in $abstractions; do
	# 	if [ "x$abstraction" = xcryptodisk ]; then
	#		return 1
	#	fi
	#done

	return 1;
}

sub prepare_grub_to_access_device($){
	my $dev=shift;
	my @line;
	local $_;

	die unless $dev;
	my @partmap=grub_probe_d partmap=>$dev;		die unless shift @partmap;
	foreach(@partmap){
		if(/^netbsd$/){push @line, "insmod part_bsd\n";next;}
		if(/^openbsd$/){push @line, "insmod part_bsd\n";next;}
		push @line, "insmod part_$_\n";
	}

	### TODO
#	loop_file=
#	case $1 in
#		/dev/loop/*|/dev/loop[0-9])
#			grub_loop_device="${1#/dev/}"
#			loop_file=`losetup "$1" | sed -e "s/^[^(]*(\([^)]\+\)).*/\1/"`
#			case $loop_file in
#				/dev/*) ;;
#				*)
#					loop_device="$1"
#					shift
#					set -- `"${grub_probe}" --target=device "${loop_file}"` "$@" || return 0
#				;;
#			esac
#		;;
#	esac

	# Abstraction modules aren't auto-loaded.
	my @abstraction=grub_probe_d abstraction=>$dev;		die unless shift @abstraction;
	push @line, "insmod $_\n" foreach(@abstraction);

	my @fs=grub_probe_d fs=>$dev;				die unless shift @fs;
	push @line, "insmod $_\n" foreach(@fs);

	### TODO
#	if [ x$GRUB_ENABLE_CRYPTODISK = xy ]; then
#			for uuid in "`"${grub_probe}" --device $@ --target=cryptodisk_uuid`"; do
#		echo "cryptomount -u $uuid"
#			done
#	fi

	# If there's a filesystem UUID that GRUB is capable of identifying, use it;
	# otherwise set root as per value in device.map.
	my @fs_hint=grub_probe_d compatibility_hint=>$dev;	die unless shift @fs_hint;
	push @line, "set root='$_'\n" foreach(@fs_hint);
	my @hints=grub_probe_d hints_string=>$dev;			die unless shift @hints;
	my @fs_uuid=grub_probe_d fs_uuid=>$dev;			die unless shift @fs_uuid;
	foreach(@fs_uuid){
		#warn join ', ', map {"'$_'"} @hints;
		if(@hints){
			push @line, "if [ x\$feature_platform_search_hint = xy ]; then\n";
			push @line, "\tsearch --no-floppy --fs-uuid --set=root @hints $_\n";
			push @line, "else\n";
			push @line, "\tsearch --no-floppy --fs-uuid --set=root $_\n";
			push @line, "fi\n";
		}else{
			push @line, "search --no-floppy --fs-uuid --set=root $_\n";
		}
	}

	### TODO
#	if [ "x${loop_file}" != x ]; then
#		loop_mountpoint="$(awk '"'${loop_file}'" ~ "^"$2 && $2 != "/" { print $2 }' /proc/mounts | tail -n1)"
#		if [ "x${loop_mountpoint}" != x ]; then
#			echo "loopback ${grub_loop_device} ${loop_file#$loop_mountpoint}"
#			echo "set root=(${grub_loop_device})"
#		fi
#	fi
	return @line;
}

sub prepare_grub_to_access_file($){
	my$path=shift;
	my @d=grub_probe device=>$path;
	#warn join ', ', @a;
	return 0 unless $d[0];
	die unless $d[1];
	return prepare_grub_to_access_device($d[1]);
}

sub is_path_readable($){
	my$path=shift;
	return 1 if 'net'eq$go{target};
	return is_path_readable_by_grub($path) if 'grub'eq$go{bl};
	return 0;
}

sub prepare_to_access_file($){
	my$path=shift;
	return () if 'net'eq$go{target};
	return prepare_grub_to_access_file($path) if 'grub'eq$go{bl};
	return ();
}

sub make_system_path_relative_to_its_root($){
	my$path=shift;
	return $path if 'net'eq$go{target};
	if('grub'eq$go{bl}){
		my @l = grub_mkrelpath($path);
		die unless shift @l;
		return '($root)'.$l[0];
	};
	return $path;
}

sub file_probe($$){
	my$target=shift;
	my$path=shift;
	return 'net' if 'net'eq$go{target};
	if('grub'eq$go{bl}){
		my @d=grub_probe device=>$path;
		die unless shift @d;
		return $d[0];
	};
	return ();
}

sub grub_load_fonts_and_gfxmod($$$@){
	my $h=shift; #handle
	my $o=shift;
	my $all=shift;

	local $_;
	my (%mod,@font);

	foreach my $path(@_){
		next unless is_path_readable ${path};
		unless(defined $path){
			next;
		}elsif(ref $path){
			warn $path;
			warn join ', ', map {"'$_'"} caller;
			die;
		}elsif(-d $go{prefix}.$path){
			open my $fh, '-|', 'find', $go{prefix}.$path, qw( ( -iname *.pf2 -o -iname *.jpg -o -iname *.jpeg -o -iname *.tga -o -iname *.png ) -print0) or die __('Cannot run find!');
			local $/=chr 0;
			my @ft;
			while(<$fh>){
				chomp;
				if(/\.png/i){$mod{png}++;next;}
				if(/\.jpg/i){$mod{jpeg}++;next;}
				if(/\.jpeg/i){$mod{jpeg}++;next;}
				if(/\.tga/i){$mod{tga}++;next;}
				s/^$go{prefix}//;
				if(/\.pf2/i){push @ft,$_;next;}
				warn $_;
			}
			push @font, sort @ft;
		}elsif(-f $go{prefix}.$path){
			foreach($go{prefix}.$path){
				chomp;
				if(/\.png/i){$mod{png}++;next;}
				if(/\.jpg/i){$mod{jpeg}++;next;}
				if(/\.jpeg/i){$mod{jpeg}++;next;}
				if(/\.tga/i){$mod{tga}++;next;}
				if(/\.pf2/i){push @font,$path;next;}
				warn $_;
			}
		}else{
			die sprintf __("Path is not file or directory: '%s'"), $path;
		}
	}
	printf {$h} ('	'x$o)."if ! insmod %s; then return 1; fi\n",$_ foreach(sort keys %mod);
	my $last='';
	foreach my $path(@font){
		my $cur=file_probe device=>$path;
		unless($cur eq$last){
			$last=$cur;
			print {$h} map {s/^(insmod .*)$/if ! $1; then return 1; fi/;('	'x$o).$_} prepare_to_access_file($path);
		}
		$path=make_system_path_relative_to_its_root $path;
		if($all){
			printf {$h} ('	'x$o)."if ! loadfont %s; then return 1; fi\n",$path;
		}else{
			printf {$h} ('	'x$o)."if loadfont %s; then return 0; fi\n",$path;
		}
	}
}

my %i=(
	grub=>{
		out=>sub(\*){
			my $h=shift;

			do_menu(grub=>menu=>*$h,menu=>0);
			foreach my $e (@order){
				next unless defined $e;
			}
		},
		config=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			warn if $e ne $order[0];
			$e->{prefix}=''unless $e->{prefix};
			$go{prefix}=$e->{prefix} if defined $e->{prefix};
			$go{target}=$e->{target} if defined $e->{target};
			$go{bl}='grub';
			$menudomain{$e->{file}}=$e->{msgset} if $e->{msgset};
			print {$h} << 'EOF';
function start_ser {
	if ! insmod serial; then
		echo serial load failed
		set serr=4
	elif ! serial --unit=0 --speed=115200;then
		echo serial conf err
		set serr=3
	elif ! terminal_output --append serial; then
		echo output error
		set serr=2
	elif ! terminal_input --append serial; then
		echo input set err
		set serr=1
	else
		echo mark 1
		set serr=0
	fi
}

function savedefault {
	if [ -z "${boot_once}" ]; then
		saved_entry="${chosen}"
		save_env saved_entry
	fi
}

if cpuid -l ; then
	set arch=amd64
	set xarch=amd64
else
	set arch=i386
	if cpuid -p ; then
		set xarch=i686-pae
	else
		set xarch=i586
	fi
fi
export arch

function gfxmode {
	set gfxpayload="${1}"
}
set linux_gfx_mode=
export linux_gfx_mode

insmod gzio
if [ x$grub_platform = xxen ]; then insmod xzio; insmod lzopio; fi

EOF
			print {$h} "function load_theme {\n";
			if($e->{grub_theme} && -f $e->{prefix}.$e->{grub_theme} && is_path_readable($e->{prefix}.$e->{grub_theme})){
				print {$h} "\tif ! insmod gfxmenu; then return 1; fi\n";
				my $themedir=$e->{grub_theme};
				$themedir=~s!/[^/]*$!!;
				grub_load_fonts_and_gfxmod($h,$o+1,1,$themedir);
				printf {$h} "\tset theme=%s\n", make_system_path_relative_to_its_root($e->{grub_theme});
			}else{
				print {$h} "\tfalse\n";
				warn sprintf __('Grub theme not readable by boot loader %s'), $e->{grub_theme} if $e->{grub_theme};
				#warn sprintf __('Grub theme not readable by script %s'), $e->{grub_theme} if ! -f $e->{grub_theme};
			}
			print {$h} "}\n\nfunction load_background {\n";
			if($e->{grub_background}){
				grub_load_fonts_and_gfxmod($h,$o+1,1,$e->{grub_background});
				print {$h} map {s/^(insmod .*)$/if ! $1; then return 1; fi/;s/^/\t/;$_} prepare_to_access_file($e->{grub_background});
				printf {$h} "\tif ! background_image -m stretch %s; then return 1; fi\n", make_system_path_relative_to_its_root($e->{grub_background});
			}else{
				print {$h} "\tfalse\n";
			}
			print {$h} "}\n\nfunction load_font {\n";
			grub_load_fonts_and_gfxmod($h,$o+1,0,$e->{grub_font})if defined $e->{grub_font};
			print {$h} "\tif [ x\$feature_default_font_path = xy ] ; then\n";
			printf {$h} "\t\tif loadfont %s; then return 0; fi\n",$_ foreach(qw(unicode unifont ascii));
			print {$h} "\t\treturn 1\n";
			print {$h} "\telse\n";
			grub_load_fonts_and_gfxmod($h,$o+2,0, grep {-e} map {my @a;foreach my $base(qw(unicode unifont ascii)){push @a,"$_/$base.pf2"}@a} ('disk'eq$go{target}?qw(/boot/grub /usr/share/grub):()));
			print {$h} "\t\treturn 1\n";
			print {$h} "\tfi\n";
			print {$h} "}\n\nfunction load_video {\n";
			print {$h} "\tif load_font ; then\n";
			print {$h} << "EOF";
		set gfxmode=auto
		if [ x\$feature_all_video_module = xy ]; then
			insmod all_video
		else
			insmod efi_gop
			insmod efi_uga
			insmod ieee1275_fb
			insmod vbe
			insmod vga
			insmod video_bochs
			insmod video_cirrus
		fi
		if insmod gfxterm; then
			if terminal_output --append gfxterm ; then
				terminal_output --remove console
			fi
		fi
		set locale_dir=\$prefix/locale
		if [ -n "\${1}" ] ; then
			set lang="\${1}"
		fi
		insmod gettext
	fi

	if load_theme; then
		export theme
	elif load_background; then
		set color_normal=white/black
		set color_highlight=black/white
	else
		set menu_color_normal=cyan/blue
		set menu_color_highlight=white/blue
	fi
}

EOF
			if('disk'eq$go{target}){
				print {$h} << 'EOF';
if [ -s $prefix/grubenv ]; then
	load_env
	set have_grubenv=true
fi

if [ "${next_entry}" ] ; then
	set default="${next_entry}"
	set next_entry=
	save_env next_entry
	set boot_once=true
EOF
				print {$h} << "EOF" if defined $e->{default};
else
	set default="$e->{default}"
EOF
				print {$h} << 'EOF';
fi

EOF
			}elsif(defined $e->{default}){
				print {$h} << "EOF";
set default="$e->{default}"
EOF
			}
			print {$h} << 'EOF';
if [ x"${feature_menuentry_id}" = xy ]; then
	menuentry_id_option="--id"
else
	menuentry_id_option=""
fi

export menuentry_id_option

if [ "${prev_saved_entry}" ]; then
	set saved_entry="${prev_saved_entry}"
	save_env saved_entry
	set prev_saved_entry=
	save_env prev_saved_entry
	set boot_once=true
fi

EOF
			print {$h} << "EOF" if defined $e->{timeout};
if [ "\${recordfail}" = 1 ] ; then
	set timeout=-1
else
	if [ x\$feature_timeout_style = xy ] ; then
		set timeout_style=menu
	fi
	set timeout=$e->{timeout}
fi

EOF
			print {$h} ('	'x$o), 'load_video',($e->{lang}?' "'.$e->{lang}.'"':()),"\n";
			print {$h} ('	'x$o), "start_ser\n\n";
		},
		gap=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			print {$h} ('	'x$o),q(menuenty '),___t($e),q(');
			print {$h} ' ',join ' ', map {'--class '.$_} split /,/, $e->{class} if defined $e->{class};
			print {$h} qq( {}\n);
		},
		gapvar		=>sub{warn __("unfinished code");},
		'read-var'	=>sub{warn __("unfinished code");},
		'submenu-var'	=>sub{warn __("unfinished code");},
		'submenu-edit'	=>sub{warn __("unfinished code");},
		exit=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			print {$h} ('	'x$o),q(menuentry '),___t($e),q(');
			print {$h} ' --users ',"'", $e->{users},"'" if defined $e->{users};
			print {$h} ' ',join ' ', map {'--class '.$_} split /,/, $e->{class} if defined $e->{class};
			print {$h} qq( {\n),('	'x$o),qq(	$e->{exit}\n),('	'x$o),qq(}\n);
		},
		kfreebsd=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			warn __('No kernel') unless defined $e->{kernel};
			print {$h} ('	'x$o),q(menuentry '),___t($e),q(');
			print {$h} ' --users ',"'", $e->{users},"'" if defined $e->{users};
			print {$h} ' ',join ' ', map {'--class '.$_} split /,/, $e->{class} if defined $e->{class};
			print {$h} qq( {\n),('	'x$o),q(	echo	');
			my $ks=$e->{kernel};$ks=~s! .*$!!;$ks=~s!^.*/!!;
			printf {$h} __(q(Loading kernel %s ...)),$ks;
			print {$h} qq('\n),('	'x$o),qq(	$e->{type}	$e->{kernel}\n);;
			if(defined $e->{initrd}){
				print {$h} ('	'x$o),qq(	echo	');
				my $is=$e->{initrd};$is=~s! .*$!!;$is=~s!^.*/!!;
				printf {$h} __(q(Loading initial ramdisk %s ...)),$is;
				print {$h} qq('\n),('	'x$o),qq(	kfreebsd_module $e->{initrd} type=mfs_root\n);
			}
			print {$h} map {('	'x$o),qq(	set $_\n)} split / /, $e->{command} if defined $e->{command};
			print {$h} ('	'x$o),qq(	echo	'$__{'Booting ...'}'\n),('	'x$o),qq(}\n);
		},
		memdisk=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			warn __('No initrd') unless defined $e->{initrd};
			print {$h} ('	'x$o),q(menuentry '),___t($e),q(');
			print {$h} ' --users ',"'", $e->{users},"'" if defined $e->{users};
			print {$h} ' ',join ' ', map {'--class '.$_} split /,/, $e->{class} if defined $e->{class};
			print {$h} qq( {\n),('	'x$o),qq(	echo	');
			printf {$h} __(q(Loading kernel %s ...)),'memdisk';
			print {$h} qq('\n),('	'x$o);
			print {$h} qq(	linux16	/memdisk);
			print {$h} qq( $e->{command}) if defined $e->{command};
			print {$h} qq(\n);
			print {$h} ('	'x$o),qq(	echo	');
			my $is=$e->{initrd};$is=~s! .*$!!;$is=~s!^.*/!!;
			printf {$h} __(q(Loading initial ramdisk %s ...)),$is;
			print {$h} qq('\n),('	'x$o),qq(	initrd16	$e->{initrd}\n);
			print {$h} ('	'x$o),qq(	echo	'$__{'Booting ...'}'\n),('	'x$o),qq(}\n);
		},
		submenu=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			print {$h} ('	'x$o),q(submenu '),___t($e),q(');
			print {$h} ' --users ',"'", $e->{users},"'" if defined $e->{users};
			print {$h} ' ',join ' ', map {'--class '.$_} split /,/, $e->{class} if defined $e->{class};
			print {$h} q( $menuentry_id_option '),$e->{id},q(') if defined $e->{id};
			print {$h} qq( {\n);
			do_menu(grub=>$e->{tag},*$h,$t,$o+1);
			print {$h} ('	'x$o),qq(}\n);
		}
	},
	pxelinux=>{
		out=>sub (\*){
			my $h=shift;

			do_menu(pxelinux=>menu=>*$h,menu=>0);
		},
		config=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			$menudomain{$e->{file}}=$e->{msgset} if $e->{msgset};
			warn __("default unimplemented") if defined $e->{default};
			warn __("timeout unimplemented") if defined $e->{timeout};
			print {$h} << 'EOF';
menu hshift 7
menu width 61

menu title Debian GNU/Linux installer boot menu
include debian-installer/boot-screens/stdmenu.cfg
EOF
			;#print {$h} ('	'x$o), 'set default="'.$e->{default}."\"\n\n" if defined $e->{default};
			;#print {$h} ('	'x$o), 'set timeout=' .$e->{timeout}.  "\n\n" if defined $e->{timeout};
		},
		gap=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			warn __("class unimplemented") if defined $e->{class};
			warn __("security unimplemented") if defined $e->{users};
			print {$h} ('	'x$o),q(menu seperator),qq(\n);
			warn __("unfinished code");
		},
		gapvar=>sub{warn __("unfinished code");},
		'submenu-var'=>sub{warn __("unfinished code");},
		'submenu-edit'=>sub{warn __("unfinished code");},
		'read-var'=>sub{warn __("unfinished code");},
		kfreebsd=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			warn __('class unimplemented') if defined $e->{class};
			warn __('security unimplemented') if defined $e->{users};
			warn __('No kernel') unless defined $e->{kernel};
			print {$h} ('	'x$o),q(default ),$e->{tag},qq(\n) if defined $e->{default} and ! $o;
			print {$h} ('	'x$o),q(label ),$e->{tag},qq(\n);
################################################################################
			print {$h} ('	'x$o),qq(	text help\n),('	'x($o+2)),$e->{help},qq(\n),('	'x$o),qq(\tendtext\n) if defined $e->{help};;
			print {$h} ('	'x$o),q(	menu default),qq(\n) if defined $e->{default};
			my $title=___t($e);
			if(defined $e->{hotkey}){
				my $hk=___h($e);
				if($title=~s/^($hk)/^$1/i){
				}elsif($title=~s/ ($hk)/ ^$1/i){
				}elsif($title=~s/($hk)/^$1/i){
				}elsif($hk!=$e->{hotkey}){
					$title=~s/$/ (^$hk)/;
				}else{
					warn sprintf __('unmarked hotkey on %s: "%s", "%s"'),$e->{tag}, $hk, $title;
				}
			}
			print {$h} ('	'x$o),qq(	menu label $title\n) if defined $e->{title};
			print {$h} ('	'x$o),qq(	kernel /mboot.c32\n);
			print {$h} ('	'x$o),q(	append ),$e->{kernel};
			print {$h} q( ),$e->{command} if defined $e->{command};
			print {$h} ' -- ',$e->{initrd} if defined $e->{initrd};
			print {$h} qq(\n)
		},
		memdisk=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			warn __("class unimplemented") if defined $e->{class};
			warn __("security unimplemented") if defined $e->{users};
			warn __('No initrd') unless defined $e->{initrd};
			print {$h} ('	'x$o),q(default ),$e->{tag},qq(\n) if defined $e->{default} and ! $o;
			print {$h} ('	'x$o),q(label ),$e->{tag},qq(\n);
################################################################################
			print {$h} ('	'x$o),qq(	text help\n),('	'x($o+2)),___o($e,'help'),qq(\n),('	'x$o),qq(\tendtext\n) if defined $e->{help};;
			print {$h} ('	'x$o),q(	menu default),qq(\n) if defined $e->{default};
			my $title=___t($e);
			if(defined $e->{hotkey}){
				my $hk=___h($e);
				if($title=~s/^($hk)/^$1/i){
				}elsif($title=~s/ ($hk)/ ^$1/i){
				}elsif($title=~s/($hk)/^$1/i){
				}elsif($hk!=$e->{hotkey}){
					$title=~s/$/ (^$hk)/;
				}else{
					warn sprintf __('unmarked hotkey on %s: "%s", "%s"'),$e->{tag}, $hk, $title;
				}
			}
			print {$h} ('	'x$o),qq(	menu label $title\n) if defined $e->{title};
			print {$h} ('	'x$o),q(	kernel /memdisk),qq(\n);
			print {$h} ('	'x$o),q(	initrd ),$e->{initrd},qq(\n) if defined $e->{initrd};
			print {$h} ('	'x$o),q(	append ),$e->{command},qq(\n) if defined $e->{command};
		},
		submenu=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			warn __("class unimplemented") if defined $e->{class};
			warn __("security unimplemented") if defined $e->{users};
			print {$h} ('	'x$o),q(menu begin ),$e->{tag},qq(\n);
			print {$h} ('	'x$o),q(	include debian-installer/boot-screens/stdmenu.cfg),qq(\n);
			my $title=___t($e);
			if(defined $e->{hotkey}){
				my $hk=___h($e);
				if($title=~s/^($hk)/^$1/i){
				}elsif($title=~s/ ($hk)/ ^$1/i){
				}elsif($title=~s/($hk)/^$1/i){
				}elsif($hk!=$e->{hotkey}){
					$title=~s/$/ (^$hk)/;
				}else{
					warn sprintf __('unmarked hotkey on %s: "%s", "%s"'),$e->{tag}, $hk, $title;
				}
			}
			print {$h} ('	'x$o),q(	menu title ),___o($e,'lable'),qq(\n) if defined $e->{lable};;
			print {$h} ('	'x$o),qq(	menu label $title\n) if defined $e->{title};
################################################################################
			print {$h} ('	'x$o),qq(	text help\n),('	'x($o+2)),___o($e,'help'),qq(\n),('	'x$o),qq(\tendtext\n) if defined $e->{help};;
			print {$h} ('	'x$o),q(	label back),$e->{tag},qq(\n);
			print {$h} ('	'x$o),q(		menu label ^Back..),qq(\n);
################################################################################
			print {$h} ('	'x$o),qq(		text help\n),('	'x($o+3)),___o($e,q{backhelp}),qq(\n),('	'x$o),qq(\t\tendtext\n) if defined $e->{backhelp};;
			print {$h} ('	'x$o),q(		menu exit),qq(\n);
			do_menu(pxelinux=>$e->{tag},*$h,$t,$o+1);
			print {$h} ('	'x$o),qq(menu end\n);
		},
		subfile=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			warn __("class unimplemented") if defined $e->{class};
			warn __("security unimplemented") if defined $e->{users};
			warn __('No file') unless defined $e->{file};
			print {$h} ('	'x$o),q(default ),$e->{tag},qq(\n) if defined $e->{default} and ! $o;
			print {$h} ('	'x$o),q(label ),$e->{tag},qq(\n);
################################################################################
			print {$h} ('	'x$o),qq(	text help\n),('	'x($o+2)),$e->{help},qq(\n),('	'x$o),qq(\tendtext\n) if defined $e->{help};;
			print {$h} ('	'x$o),q(	menu default),qq(\n) if defined $e->{default};
			unless(defined $e->{hotkey}){
			}elsif($e->{title}=~s/^($e->{hotkey})/^$1/i){
			}elsif($e->{title}=~s/ ($e->{hotkey})/ ^$1/i){
			}elsif($e->{title}=~s/($e->{hotkey})/^$1/i){
			}else{
				warn sprintf __("unmarked hotkey on %s: %s"),$e->{tag}, $e->{title};
			}
			print {$h} ('	'x$o),q(	menu label ),$e->{title},qq(\n) if defined $e->{title};
			print {$h} ('	'x$o),q(	config ),$e->{file},qq(\n);
		}
	},
	ipxe=>{
		config=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			$menudomain{$e->{file}}=$e->{msgset} if $e->{msgset};
			warn __("class unimplemented") if defined $e->{class};
			warn __("security unimplemented") if defined $e->{users};
			if(defined $e->{npreseed}){
				$e->{snpreseed}=$e->{npreseed};
				$e->{snpreseed}=~s!^.*/!!;
			}
			print {$h} 'isset ${'.$_.'} || set '.$_.' '.$e->{$_}."\n" foreach (grep {$e->{$_}} qw(
				video debug preseed npreseed snpreseed desktop default timeout
				dvideo dmode
			));
			print {$h} "\n";
			print {$h} 'isset ${'.$_.'} || set '.$_.' '.$e->{$_}."\n" foreach (grep {$e->{$_}} qw(
				vid dpreseed ddesktop
			));
			print {$h} << 'EOF';
isset ${vid} || set vid ${video}
isset ${dpreseed} || set dpreseed url=${preseed}
isset ${ddesktop} || set ddesktop desktop=${desktop}
EOF
			print {$h} "\n";
		},
		out=>sub (\*){
			my $h=shift;
			#do_menu(ipxe=>menu=>*$h,menu=>0);
			print {$h} << 'EOF';
console --picture splash.png || console --picture splash.pgm ||
set pxe_default_server ${next-server}
cpuid --ext 29 && set arch amd64 || set arch i386
cpuid 6 && set pae yes ||
cpuid --ext 29 && set xarch amd64 || cpuid 6 && set xarch i686-pae || set xarch i586
cpuid --ecx 5 && set vmx yes ||
cpuid --ext --ecx 2 && set svm yes ||
isset ${vmx} || isset ${svm} && set hw_virt yes ||
set esc:hex 1b
set lf:hex 0a
set space:hex 20

EOF
			print {$h} qq(:menu\nmenu --name menu\n);
			do_menu(ipxe1=>menu=>*$h,menu=>0);
			print {$h} qq(choose --menu menu target || exit\nmenu --name menu --delete\ngoto \${target}\n\n);
			foreach my $e (@order){
				next unless defined $e;
				unless(defined $e->{type}){
					warn __('undefined type for entry');
					next;
				}
				next if(defined $e->{only}); # meaning inverted by parser
				entry('ipxe2',*$h,$e,menu=>0);
			}
		}
	},
	ipxe1=>{
		config2=>sub{},
		config=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			$menudomain{$e->{file}}=$e->{msgset} if $e->{msgset};
			warn __("class unimplemented") if defined $e->{class};
			warn __("security unimplemented") if defined $e->{users};
			if(defined $e->{npreseed}){
				$e->{snpreseed}=$e->{npreseed};
				$e->{snpreseed}=~s!^.*/!!;
			}
			print {$h} 'isset ${'.$_.'} || set '.$_.' '.$e->{$_}."\n" foreach (grep {$e->{$_}} qw(
				video debug preseed npreseed snpreseed desktop default timeout
				dvideo dmode
			));
			print {$h} "\n";
			print {$h} 'isset ${'.$_.'} || set '.$_.' '.$e->{$_}."\n" foreach (grep {$e->{$_}} qw(
				vid dpreseed ddesktop
			));
			print {$h} << 'EOF';
isset ${vid} || set vid ${video}
isset ${dpreseed} || set dpreseed url=${preseed}
isset ${ddesktop} || set ddesktop desktop=${desktop}
EOF
			print {$h} "\n";
		},
		gap=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			warn __("class unimplemented") if defined $e->{class};
			warn __("security unimplemented") if defined $e->{users};
			print {$h} q(item ),($t?"--menu $t ":''),"--gap",($e->{title}?" $e->{title}":''),qq(\n);
		},
		gapvar=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			warn __("class unimplemented") if defined $e->{class};
			warn __("security unimplemented") if defined $e->{users};
			print {$h} qq(isset \${$e->{var}} && );
			print {$h} q(item ),($t?"--menu $t ":''),"--gap ",qq($e->{titlet} || );
			print {$h} q(item ),($t?"--menu $t ":''),"--gap ",qq($e->{titlef}\n);
		},
		value=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			warn __("class unimplemented") if defined $e->{class};
			warn __("security unimplemented") if defined $e->{users};
			$e->{tag}=$e->{value} if defined $e->{value};
			unless(defined $e->{hotkey}){
			}elsif($e->{title}=~s/^($e->{hotkey})/($1)/i){
			}elsif($e->{title}=~s/ ($e->{hotkey})/ ($1)/i){
			}elsif($e->{title}=~s/($e->{hotkey})/($1)/i){
			}else{
				warn sprintf __("unmarked hotkey on %s: %s"),$e->{tag}, $e->{title};
			}
			print {$h} 'item ',_f('--menu %s ',$t),
				_f('--key %s ',$e->{hotkey}),
				($e->{default}?"--default ":''),
				qq($e->{tag}\t$e->{title}\n) unless $e->{hidden};
		},
		'value-read'=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			warn __("class unimplemented") if defined $e->{class};
			warn __("security unimplemented") if defined $e->{users};
			$e->{tag}=$e->{value} if defined $e->{value};
			unless(defined $e->{hotkey}){
			}elsif($e->{title}=~s/^($e->{hotkey})/($1)/i){
			}elsif($e->{title}=~s/ ($e->{hotkey})/ ($1)/i){
			}elsif($e->{title}=~s/($e->{hotkey})/($1)/i){
			}else{
				warn sprintf __("unmarked hotkey on %s: %s"),$e->{tag}, $e->{title};
			}
			print {$h} 'item ',_f('--menu %s ',$t),
				_f('--key %s ',$e->{hotkey}),
				($e->{default}?"--default ":''),
				qq($e->{tag}\t$e->{title}\n) unless $e->{hidden};
		},
	},
	ipxe2=>{
		config=>sub{},
		gap=>sub{},
		gapvar=>sub{},
		value=>sub{},
		'value-read'=>sub{},
		sanboot=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

################################################################################
			print {$h} qq(:$e->{tag}\nisset \${sanid} && inc sanid || set sanid:int8 0x80 \nsanboot --drive \${sanid:int8} $e->{path} || goto debug-$e->{tag}\ngoto $e->{under}\n\n);
			print {$h} qq(:debug-$e->{tag}\nshell\ngoto $e->{under}\n\n);
		},
		sanhook=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

################################################################################
			print {$h} qq(:$e->{tag}\nisset \${sanid} && inc sanid || set sanid:int8 0x80 \nsanhook --drive \${sanid:int8} $e->{path} || goto debug-$e->{tag}\ngoto $e->{under}\n\n);
			print {$h} qq(:debug-$e->{tag}\nshell\ngoto $e->{under}\n\n);
		},
		exit=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			print {$h} q(:),$e->{tag},"\n",$e->{exit},qq( || goto debug-$e->{tag}\ngoto $e->{under}\n\n);
			print {$h} qq(:debug-$e->{tag}\nshell\ngoto $e->{under}\n\n);
		},
		memdisk=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			print {$h} q(:),$e->{tag};
			print {$h} qq(\necho	Loading kernel ...\n);
			print {$h} qq(kernel	../tftpboot/memdisk);
			print {$h} qq( $e->{command}) if defined $e->{command};
################################################################################
			print {$h} qq( || goto debug-$e->{tag}\necho	Loading initial ramdisk ...\ninitrd	$e->{initrd}) if defined $e->{initrd};
			print {$h} qq( || goto debug-$e->{tag}\nimgstat\necho	Booting ...\nboot || goto debug-$e->{tag}\nimgfree || goto debug-$e->{tag}\ngoto $e->{under}\n\n);
			print {$h} qq(:debug-$e->{tag}\nshell\ngoto $e->{under}\n\n);
		},
		kfreebsd=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			print {$h} q(:),$e->{tag};
			print {$h} qq(\necho	Loading kernel ...\nimgstat\nshell\n);
			warn __("kfreebsd may not work");
				print {$h} qq(kernel	$e->{kernel});
				print {$h} qq( $e->{command}) if defined $e->{command};
################################################################################
				print {$h} qq( || goto debug-$e->{tag}\necho	Loading initial ramdisk ...\ninitrd	$e->{initrd}) if defined $e->{initrd};
				print {$h} map {qq( || goto debug-$e->{tag}\necho	Loading initial ramdisk ...\ninitrd	$_)} split /:/, $e->{xinitrd} if defined $e->{xinitrd};
				print {$h} qq( || goto debug-$e->{tag}\nimgstat || goto debug-$e->{tag}\necho	Booting ...\nboot || goto debug-$e->{tag}\nimgfree || goto debug-$e->{tag}\ngoto $e->{under}\n\n);
				print {$h} q(:debug-),$e->{tag},qq(\nshell\ngoto $e->{under}\n\n);
		},
		submenu=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			$e->{label}=$e->{title} unless defined $e->{label};
			print {$h} q(:),$e->{tag},qq(\n);
			print {$h} qq(menu --name $e->{tag} $e->{label}\n);
			do_menu(ipxe1=>$e->{tag},*$h,$e->{tag},$o+1);
			print {$h} qq(item --menu $e->{tag} --gap\n);
			print {$h} qq(item --menu $e->{tag} $e->{under}	Back to Parrent menu\n);
			print {$h} qq(choose --menu $e->{tag} target || goto $e->{under}\nmenu --name $e->{tag} --delete\n);
			print {$h} join "\n", split(';', $e->{extended}), '' if defined $e->{extended};
			print {$h} qq(goto \${target}\n\n);
		},
		'read-var'=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			print {$h} q(:),$e->{tag}, qq(\nread $e->{var} || clear $e->{var} \n);
			print {$h} join "\n", split(';', $e->{extended}), '' if defined $e->{extended};
			print {$h} qq(goto $e->{under}\n\n);
		},
		'submenu-var'=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			$e->{label}=$e->{title} unless defined $e->{label};
			print {$h} q(:),$e->{tag};
			print {$h} qq(\nmenu --name $e->{tag} $e->{label}\n);
			do_menu(ipxe1=>$e->{tag},*$h,$e->{tag},$o+1);
			print {$h} qq(choose --menu $e->{tag} $e->{var} || $e->{cancel}\n);
			print {$h} join "\n", split(';', $e->{extended}), '' if defined $e->{extended};
			print {$h} qq(goto $e->{under}\n\n);
		},
		'submenu-var-ex'=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			$e->{label}=$e->{title} unless defined $e->{label};
			print {$h} q(:),$e->{tag};
			print {$h} qq(\nmenu --name $e->{tag} $e->{label}\n);
			do_menu(ipxe1=>$e->{tag},*$h,$e->{tag},$o+1);
			print {$h} qq(choose --menu $e->{tag} $e->{var} || $e->{cancel}\n);
			print {$h} join "\n", split(';', $e->{extended}), '' if defined $e->{extended};
			print {$h} qq(isset \${$e->{var}} && goto $e->{tag}-\${$e->{var}} ||\n);
			print {$h} qq(goto $e->{under}\n);
			do_menu(ipxe3=>$e->{tag},*$h,$e->{tag},$e->{under});
			print {$h} qq(\n);
		},
		'submenu-edit'=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			if('linux16'eq$e->{subtype}){
			}elsif('linux'eq$e->{subtype}){
			}elsif('multiboot'eq$e->{subtype}){
			#}elsif('ipxelong'eq$e->{subtype}){
			}else{
				warn sprintf __(qq(Unknown kernel type %s)),$e->{subtype};
			}

			warn __('No kernel') unless defined $e->{kernel};
			$e->{label}=$e->{title} unless defined $e->{label};
			print {$h} q(:),$e->{tag};
			print {$h} qq(\nset kernel $e->{kernel}\n);
			print {$h} qq(set command $e->{command}\n) if defined $e->{command};
			print {$h} qq(set initrd $e->{initrd}\n) if defined $e->{initrd};
			print {$h} q(:),$e->{tag};
			print {$h} qq(-cont\nmenu --name $e->{tag} $e->{label}\n);
			print {$h} qq(item --menu $e->{tag} --gap \${space:string}Kernel: \${kernel}\n);
			print {$h} qq(item --menu $e->{tag} --gap \${space:string}Initrd: \${initrd}\n);
			print {$h} qq(item --menu $e->{tag} --gap Command: \${command}\n);
			print {$h} qq(isset \${npreseed} && item --menu $e->{tag} --gap Early Preseed: \${npreseed} || item --menu $e->{tag} --gap No Early Preseed\n);
			print {$h} qq(item --menu $e->{tag} --gap\n);
			print {$h} qq(item --menu $e->{tag} --key K	chkr-$e->{tag}	Edit (K)ernel\n);
			print {$h} qq(item --menu $e->{tag} --key I	chin-$e->{tag}	Edit (I)nitrd\n);
			print {$h} qq(item --menu $e->{tag} --key C	chco-$e->{tag}	Edit (C)command\n);
			print {$h} qq(item --menu $e->{tag} --key P	chpr-$e->{tag}	Edit Early (P)reseed\n);
			print {$h} qq(item --menu $e->{tag} --gap\n);
			print {$h} qq(item --menu $e->{tag} --default $e->{tag}-boot	Boot\n);
			print {$h} qq(item --menu $e->{tag} --gap\n);
			print {$h} qq(item --menu $e->{tag} $e->{under}	Back to Parrent menu\n);
################################################################################
			print {$h} qq(choose --menu $e->{tag} target || goto $e->{under}\nmenu --name $e->{tag} --delete\ngoto \${target}\n);

			print {$h} q(:chkr-),$e->{tag}, qq(\nread kernel || clear kernel \ngoto $e->{tag}-cont\n);
			print {$h} q(:chin-),$e->{tag}, qq(\nread initrd || clear initrd \ngoto $e->{tag}-cont\n);
			print {$h} q(:chco-),$e->{tag}, qq(\nread command || clear command \ngoto $e->{tag}-cont\n);
			print {$h} q(:chpr-),$e->{tag}, qq(\nread npreseed || clear npreseed \ngoto $e->{tag}-cont\n);
			print {$h} q(:),$e->{tag}, qq(-boot\necho	Loading kernel ...\n);
			print {$h} q(kernel	${kernel} ${command});
			if(('linux'eq$e->{subtype}||'linux16'eq$e->{subtype}) && ! $e->{flags}{nolinuxinitrd}){
				print {$h} q( initrd=${snpreseed}) if $e->{flags}{npreseed};
				if(defined $e->{initrd}){
					my $initrds=$e->{initrd};
					$initrds=~s!^.*/!!;
					print {$h} qq( initrd=${initrds});
				}
			}
			print {$h} q( || goto debug-),$e->{tag};
			print {$h} qq(\necho	Loading initial ramdisk ...\ninitrd	\${initrd});
################################################################################
			#print {$h} map {qq( || goto debug-$e->{tag}\necho	Loading initial ramdisk ...\ninitrd	$_)} split /:/, $e->{xinitrd} if defined $e->{xinitrd};
			print {$h} qq( || goto debug-$e->{tag}\nisset \${npreseed} || goto boot-$e->{tag}\necho	Loading ramdisk preseed ...\ninitrd	\${npreseed}) if $e->{flags}{npreseed};
			print {$h} qq( || goto debug-$e->{tag}\nimgstat || goto debug-$e->{tag}\n:boot-$e->{tag}\necho	Booting ...\nboot || goto debug-$e->{tag}\nimgfree || goto debug-$e->{tag}\ngoto $e->{under}\n\n);
			print {$h} q(:debug-),$e->{tag},qq(\nshell\ngoto $e->{tag}\n\n);
		},
	},
	ipxe3=>{
		basic=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			if('value'eq$e->{type}){
			}else{
				warn sprintf __(qq(Unknown kernel type %s)),$e->{type};
			}

			print {$h} q(:),$e->{under},'-',$e->{tag},qq(\n);
			print {$h} join "\n", split(';', $e->{extended}), '' if defined $e->{extended};
			print {$h} qq(goto $o\n);
		}
	},
	pot=>{
		out=>sub(\*){
			my $h=shift;
			do_menu(pot=>menu=>*$h,menu=>0);
		},
		config=>sub{
			use POSIX qw(strftime);

			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			$menudomain{$e->{file}}=$e->{msgset} if $e->{msgset};
			print {$h} strftime(qq(# SOME DESCRIPTIVE TITLE.\n# Co).
				qq(pyright (C) YEAR THE PACKAGE'S COPYRIGHT HO).
				qq(LDER\n# This file is distributed under the ).
				qq(same license as the Unboot package.\n# FIRS).
				qq(T AUTHOR <EMAIL\@ADDRESS>, YEAR.\n#\n#, fuz).
				qq(zy\nmsgid ""\nmsgstr ""\n"Project-Id-Versio).
				qq(n: PACKAGE VERSION\\n"\n"Report-Msgid-Bugs-).
				qq(To: 42656e\@gmail.com\\n"\n"POT-Creation-Da).
				qq(te: %F %R+0000\\n"\n"PO-Revision-Date: YEAR).
				qq(-MO-DA HO:MI+ZONE\\n"\n"Last-Translator: FU).
				qq(LL NAME <EMAIL\@ADDRESS>\\n"\n"Language-Tea).
				qq(m: LANGUAGE <LL\@li.org>\\n"\n"Language: \\).
				qq(n"\n"MIME-Version: 1.0\\n"\n"Content-Type: ).
				qq(text/plain; charset=utf8\\n"\n"Content-Tran).
				qq(sfer-Encoding: 8bit\\n"\n\n),gmtime);
		},
		basic=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			my $title=$e->{title};
			$title=~s/(["\?])/\\$1/;
			$title=~s/([^ -~])/'\x'.ord($1)/e;
################################################################################
			print {$h} qq(#. Type: menu choice text\n#. Tag: $e->{tag}\n#. Under: $e->{under}\n#: $e->{file}:$e->{line}\nmsgid "$title"\nmsgstr ""\n\n);
			print {$h} qq(#. Type: menu choice hotkey\n#. Tag: $e->{tag}\n#. Under: $e->{under}\n#: $e->{file}:$e->{line}\nmsgctxt "$title"\nmsgid "$e->{hotkey}"\nmsgstr ""\n\n) if defined $e->{hotkey};
			return unless defined $e->{label};
			my $label=$e->{label};
			$label=~s/(["\?])/\\$1/;
			$label=~s/([^ -~])/'\x'.ord($1)/e;
			print {$h} qq(#. Type: submenu label\n#. Tag: $e->{tag}\n#. Under: $e->{under}\n#: $e->{file}:$e->{line}\nmsgid "$label"\nmsgstr ""\n\n);
		},
		gap=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			return unless defined $e->{title};
			my $title=$e->{title};
			$title=~s/(["\?])/\\$1/;
			$title=~s/([^ -~])/'\x'.ord($1)/e;
			print {$h} qq(#. Type: menu additional text\n#. Tag: $e->{tag}\n#. Under: $e->{under}\n#: $e->{file}:$e->{line}\nmsgid "$title"\nmsgstr ""\n\n);
			warn __("Hotkey on unselectable entry") if defined $e->{hotkey};
		},
		gapvar=>sub{
			my $h=shift; #handle
			my $e=shift; #entry
			my $t=shift;
			my $o=shift;

			return unless defined $e->{titlet};
			return unless defined $e->{titlef};
			my $titlet=$e->{titlet};
			my $titlef=$e->{titlef};
			$titlet=~s/(["\?])/\\$1/;
			$titlef=~s/(["\?])/\\$1/;
			$titlet=~s/([^ -~])/'\x'.ord($1)/e;
			$titlef=~s/([^ -~])/'\x'.ord($1)/e;
################################################################################
			print {$h} qq(#. Type: menu additional text\n#. Tag: $e->{tag}\n#. Under: $e->{under}\n#. Variable undefined: $e->{var}\n#: $e->{file}:$e->{line}\nmsgid "$titlef"\nmsgstr ""\n\n);
			print {$h} qq(#. Type: menu additional text\n#. Tag: $e->{tag}\n#. Under: $e->{under}\n#. Variable defined: $e->{var}\n#: $e->{file}:$e->{line}\nmsgid "$titlet"\nmsgstr ""\n\n);
			warn __("Hotkey on unselectable entry") if defined $e->{hotkey};
		},
	},
);
$i{pxelinux}{basic}=sub{
	my $h=shift; #handle
	my $e=shift; #entry
	my $t=shift;
	my $o=shift;

	warn __("class unimplemented") if defined $e->{class};
	warn __("security unimplemented") if defined $e->{users};
	if('linux16'eq$e->{type}){
	}elsif('linux'eq$e->{type}){
	}elsif('multiboot'eq$e->{type}){
	}else{
		warn sprintf __(qq(Unknown kernel type %s)),$e->{type};
	}

	#todo subfile ###
	warn __('No kernel') unless defined $e->{kernel};
	print {$h} ('	'x$o),q(default ),$e->{tag},qq(\n) if defined $e->{default} and ! $o;
	print {$h} ('	'x$o),q(label ),$e->{tag},qq(\n);
	print {$h} ('	'x$o),qq(	text help\n),('	'x($o+2)),$e->{help},qq(\n),('	'x$o),qq(\tendtext\n) if defined $e->{help};;
	print {$h} ('	'x$o),q(	menu default),qq(\n) if defined $e->{default};
	unless(defined $e->{hotkey}){
	}elsif($e->{title}=~s/^($e->{hotkey})/^$1/i){
	}elsif($e->{title}=~s/ ($e->{hotkey})/ ^$1/i){
	}elsif($e->{title}=~s/($e->{hotkey})/^$1/i){
	}else{
		warn sprintf __("unmarked hotkey on %s: %s"),$e->{tag}, $e->{title};
	}
	print {$h} ('	'x$o),q(	menu label ),$e->{title},qq(\n) if defined $e->{title};
	print {$h} ('	'x$o),q(	kernel ),$e->{kernel},qq(\n);
	print {$h} ('	'x$o),q(	initrd ),$e->{initrd},qq(\n) if defined $e->{initrd};
	print {$h} ('	'x$o),q(	append ),$e->{command},qq(\n) if defined $e->{command};
};
$i{grub}{basic}=sub{
	my $h=shift; #handle
	my $e=shift; #entry
	my $t=shift;
	my $o=shift;

	#todo hotkey, default ###
	#todo subfile ###
	my $t2;
	if('linux16'eq$e->{type}){
		$t2='initrd16';
	}elsif('linux'eq$e->{type}){
		$t2='initrd';
	}elsif('multiboot'eq$e->{type}){
		$t2='error';
	}else{
		warn sprintf __(qq(Unknown kernel type %s)),$e->{type};
	}

	warn __('No kernel') unless defined $e->{kernel};
	print {$h} ('	'x$o),q(menuentry '),$e->{title},q(');
	print {$h} ' --users ',"'", $e->{users},"'" if defined $e->{users};
	print {$h} ' ',join ' ', map {'--class '.$_} split /,/, $e->{class} if defined $e->{class};
	print {$h} q( $menuentry_id_option '),$e->{id},q(') if defined $e->{id};
	print {$h} qq( {\n);
	#print {$h} ('	'x($o+1)),qq(insmod gzio\n);
	#print {$h} ('	'x($o+1)),qq(if [ x\$grub_platform = xxen ]; then insmod xzio; insmod lzopio; fi\n);
	print {$h} map {
		#s/^(insmod .*)$/if ! $1; then return 1; fi/;
		('	'x($o+1)),$_
		} prepare_to_access_file($e->{kernel});
	my $ks=$e->{kernel};$ks=~s! .*$!!;$ks=~s!^.*/!!;
	print {$h} ('	'x$o),qq(	echo	'Loading Kernel: $ks ...'\n),('	'x$o);
	print {$h} qq(	$e->{type}	),make_system_path_relative_to_its_root $e->{kernel};
	print {$h} qq( $e->{command}) if defined $e->{command};
	if(defined $e->{initrd}){
		my $ms=$e->{initrd};$ms=~s! .*$!!;$ms=~s!^.*/!!;
################################################################################
		print {$h} qq(\n),('	'x$o),qq(	echo	'Loading initial ramdisk: $ms ...'\n),('	'x$o),qq(	$t2	),make_system_path_relative_to_its_root $e->{initrd};
	}
	print {$h} qq(\n),('	'x$o),qq(	echo	'Booting ...'\n),('	'x$o),qq(}\n);
};
$i{ipxe1}{basic}=sub{
	my $h=shift; #handle
	my $e=shift; #entry
	my $t=shift;
	my $o=shift;

	warn __("class unimplemented") if defined $e->{class};
	if(defined $e->{users}){
		warn __("security partially implemented");
		return;
	}
	#todo kfreebsd
	if('kfreebsd'eq$e->{type}){
		return;
	}elsif('submenu'eq$e->{type}){
	}elsif('linux16'eq$e->{type}){
	}elsif('linux'eq$e->{type}){
	}elsif('memdisk'eq$e->{type}){
	}elsif('exit'eq$e->{type}){
	}elsif('multiboot'eq$e->{type}){
	}elsif('ipxelong'eq$e->{type}){
	}elsif('read-var'eq$e->{type}){
	}elsif('submenu-var'eq$e->{type}){
	}elsif('submenu-var-ex'eq$e->{type}){
	}elsif('submenu-edit'eq$e->{type}){
	}elsif('sanboot'eq$e->{type}){
	}elsif('sanhook'eq$e->{type}){
	}else{
		warn sprintf __(qq(Unknown kernel type %s)),$e->{type};
	}

	$e->{label}=$e->{title} unless defined $e->{label};
	unless(defined $e->{hotkey}){
	}elsif($e->{title}=~s/^($e->{hotkey})/($1)/i){
	}elsif($e->{title}=~s/ ($e->{hotkey})/ ($1)/i){
	}elsif($e->{title}=~s/($e->{hotkey})/($1)/i){
	}else{
		warn sprintf __("unmarked hotkey on %s: %s"),$e->{tag}, $e->{title};
	}
	print {$h} q(isset ${),$e->{condition},q(} && ) if $e->{condition};
	print {$h} q(item ),($t?"--menu $t ":''),($e->{hotkey}?"--key $e->{hotkey} ":''),($e->{default}?"--default ":''),$e->{tag},qq(	$e->{title} ||\n) unless $e->{hidden};
};
$i{ipxe2}{basic}=sub{
	my $h=shift; #handle
	my $e=shift; #entry
	my $t=shift;
	my $o=shift;

	if('kfreebsd'eq$e->{type}){
		return;
	}elsif('linux16'eq$e->{type}){
	}elsif('linux'eq$e->{type}){
	}elsif('multiboot'eq$e->{type}){
	}elsif('ipxelong'eq$e->{type}){
	}else{
		warn sprintf __(qq(Unknown kernel type %s)),$e->{type};
	}

	warn __('No kernel') unless defined $e->{kernel};
	print {$h} q(:),$e->{tag};
	print {$h} qq(\necho	Loading kernel ...\n);
	print {$h} qq(kernel	$e->{kernel});
	print {$h} qq( $e->{command}) if defined $e->{command};
	if($e->{flags}{npreseed} && ('linux'eq$e->{type}||'linux16'eq$e->{type}) && ! $e->{flags}{nolinuxinitrd}){
		print {$h} q( initrd=${snpreseed});
	}
	if(defined $e->{initrd} && ('linux'eq$e->{type}||'linux16'eq$e->{type}) && ! $e->{flags}{nolinuxinitrd}){
		my $initrds=$e->{initrd};
		$initrds=~s!^.*/!!;
		print {$h} qq( initrd=${initrds});
	}
################################################################################
	print {$h} qq( || goto debug-$e->{tag}\necho	Loading initial ramdisk ...\ninitrd	$e->{initrd}) if defined $e->{initrd};
	print {$h} map {qq( || goto debug-$e->{tag}\necho	Loading initial ramdisk ...\ninitrd	$_)} split /:/, $e->{xinitrd} if defined $e->{xinitrd};
	print {$h} qq( || goto debug-$e->{tag}\nisset \${npreseed} || goto boot-$e->{tag}\necho	Loading ramdisk preseed ...\ninitrd	\${npreseed}) if $e->{flags}{npreseed};
	print {$h} qq( || goto debug-$e->{tag}\nimgstat || goto debug-$e->{tag}\n:boot-$e->{tag}\necho	Booting ...\nboot || goto debug-$e->{tag}\nimgfree || goto debug-$e->{tag}\ngoto $e->{under}\n\n);
	print {$h} q(:debug-),$e->{tag},qq(\nshell\ngoto $e->{under}\n\n);
};

sub entry($\*$;$$){
	my $t=shift; #target
	my ($h,$e)=@_;

	if($i{$t}{$e->{type}}){
		return $i{$t}{$e->{type}}(@_)
	}elsif($i{$t}{basic}){
		return $i{$t}{basic}(@_);
	}else{
		die sprintf __("Unknown type '%s'"),$t;
	}
}
sub out($\*){
	my $t=shift; #target
	my $h=shift; #handle

	die __("Unknown format requested") unless defined $i{$t};
################################################################################
	printf {$h} __(qq(#!%s\n#\n# DO NOT EDIT THIS FILE\n#\n# It is automatically generated by unboot.\n#\n\n### BEGIN %s: %s ###\n)), $t, $0, $ARGV unless 'pot'eq$t;
	$i{$t}{out}($h);
	printf {$h} __(qq(### END %s: %s ###\n)),$0,$ARGV unless 'pot'eq$t;
}
sub do_menu($$\*;$$){
	my $g=shift;
	my $m=shift;
	my $h=shift;
	my $t=shift;
	my $o=shift;

	$o=0 unless defined $o;
	foreach my $e (@order){
		next unless defined $e;
		unless(defined $e->{type}){
			warn __('Undefined type for entry');
			$e=undef;
			next;
		}
		unless('pot'eq$g){
			next unless $e->{under}eq$m;
			next if(defined $e->{only}); # meaning inverted by parser
		}
		entry($g,*$h,$e,$t,$o);
	}
}

my $mode=shift;
my $count=-1;
my $marker=0;

while (<>){
	unless($marker){
		$marker++; $count++;
		$order[$count]{file}=$ARGV;
		($menudomain{$ARGV}=$ARGV)=~s/\.menu$//;
		$menudomain{$ARGV}=~s!^.*/([^/]*)!$1!;
		$order[$count]{line}=$.;
	}
	next if /^[ 	]*[#;]/;
	next if m!^[ 	]*//!;
	next if m!^[ 	]*$!;
	if(/^\[([0-9a-zA-Z-]+)\]/){
		$count++;
		$order[$count]{tag}=$1;
		$order[$count]{file}=$ARGV;
		$order[$count]{line}=$.;
	}else{
		s!^[ 	]*!!;
		s![ 	]*$!!;
		if(/^(only)[ 	]*=[ 	]*(.*)$/i){
			my @a = grep {$_ eq$mode} split /,/, $2;
			next if scalar @a;
			$order[$count]{lc($1)}++;
		}elsif(/^(flags)[ 	]*=[ 	]*(.*)$/i){
			my @a = split /,/, $2;
			$order[$count]{lc($1)}{lc($_)}++ foreach @a;
		}elsif(/^([0-9a-zA-Z_]+)[ 	]*=[ 	]*(.*)$/){
			$order[$count]{lc($1)}=$2;
		}else{
			die sprintf __('bad line format: %s'), $_;
		}
	}
} continue {
	if(eof){	# Not eof()!
		close ARGV;
		$marker=0;
	}
}
foreach my $e (@order){
	next unless defined $e;
	$e->{under}='menu' unless(defined $e->{under});
}
out($mode=>*STDOUT);
